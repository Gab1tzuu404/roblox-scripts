

local a=false;local b=nil;if table.find==nil then table.find=function(a,b,c)for c=c or 1,#a do if a[c]==b then return c end end end end;if arg and type(arg)=='table'then if table.find(arg,"--cli")then a=true end end;if a==true then if#arg==1 and arg[1]=="--cli"then print("ByteLuaObfuscator".."\n".."Copyright (c) 2022 Reboy / M0dder".."\n".."".."\n".."Usage:".."\n".."lua module.lua --cli --source \"<FILE_PATH>\" --output \"<FILE_PATH>\" [..]".."\n".."".."\n".."Available Arguments:".."\n".."--cli 	Run the script as CLI mode.".."\n".."--source \"<FILE_PATH>\" 	Path to Lua script to obfuscate.".."\n".."--output \"<FILE_PATH>\" 	Path to Lua script to output (document will be created if there isn't).".."\n".."--comment \"<COMMENT>\" 	Comment Option.".."\n".."--varcomm \"<COMMENT>\" 	Comment Option for lua variable value.".."\n".."--varname \"<STRING>\" 	Lua variable name (Special characters, spaces will be replaced with underline).".."\n".."--cryptvarcomm  	Encode (Decodable) comment for vartiable value.".."\n".."".."\n")return end;b={}local a={"source","output","comment","varcomm","varname"}local c={}for d,e in pairs(arg)do if(not table.find(c,d))or(d>0)then if e:sub(1,2)=="--"then if table.find(a,e:sub(3))then b[e:sub(3)]=arg[d+1]table.insert(c,(#c+1),(d+1))else b[e:sub(3)]=true end end end end end;local c={}local d='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'local e=d..'!@#$%&*()-=~[];\'",./_+{}:|<>?'local f=getfenv or function()return _ENV end;local d={Yueliang=(function()local a={}local b={}local c={}local d={}local e={}local f={}local g=8;local function h(a)if not a then error("assertion failed!")end end;function a:make_getS(a)local a=a;return function()if not a then return nil end;local b=a;a=nil;return b end end;function a:make_getF(a)local b=512;local c=1;return function()local d=a:sub(c,c+b-1)c=math.min(#a+1,c+b)return d end end;function a:init(a,b)if not a then return end;local c={}c.reader=a;c.data=b or""c.name=name;if not b or b==""then c.n=0 else c.n=#b end;c.p=0;return c end;function a:fill(a)local b=a.reader()a.data=b;if not b or b==""then return"EOZ"end;a.n,a.p=#b-1,1;return string.sub(b,1,1)end;function a:zgetc(a)local b,c=a.n,a.p+1;if b>0 then a.n,a.p=b-1,c;return string.sub(a.data,c,c)else return self:fill(a)end end;c.RESERVED="TK_AND and\nTK_BREAK break\nTK_DO do\nTK_ELSE else\nTK_ELSEIF elseif\nTK_END end\nTK_FALSE false\nTK_FOR for\nTK_FUNCTION function\nTK_IF if\nTK_IN in\nTK_LOCAL local\nTK_NIL nil\nTK_NOT not\nTK_OR or\nTK_REPEAT repeat\nTK_RETURN return\nTK_THEN then\nTK_TRUE true\nTK_UNTIL until\nTK_WHILE while\nTK_CONCAT ..\nTK_DOTS ...\nTK_EQ ==\nTK_GE >=\nTK_LE <=\nTK_NE ~=\nTK_NAME <name>\nTK_NUMBER <number>\nTK_STRING <string>\nTK_EOS <eof>"c.MAXSRC=80;c.MAX_INT=2147483645;c.LUA_QS="'%s'"c.LUA_COMPAT_LSTR=1;function c:init()local a,b={},{}for c in string.gmatch(self.RESERVED,"[^\n]+")do local c,c,c,d=string.find(c,"(%S+)%s+(%S+)")a[c]=d;b[d]=c end;self.tokens=a;self.enums=b end;function c:chunkid(a,b)local c;local d=string.sub(a,1,1)if d=="="then c=string.sub(a,2,b)else if d=="@"then a=string.sub(a,2)b=b-#" '...' "local d=#a;c=""if d>b then a=string.sub(a,1+d-b)c=c.."..."end;c=c..a else local d=string.find(a,"[\n\r]")d=d and d-1 or#a;b=b-#" [string \"...\"] "if d>b then d=b end;c="[string \""if d<#a then c=c..string.sub(a,1,d).."..."else c=c..a end;c=c.."\"]"end end;return c end;function c:token2str(a,a)if string.sub(a,1,3)~="TK_"then if string.find(a,"%c")then return string.format("char(%d)",string.byte(a))end;return a else return self.tokens[a]end end;function c:lexerror(a,b,c)local function d(a,b)if b=="TK_NAME"or b=="TK_STRING"or b=="TK_NUMBER"then return a.buff else return self:token2str(a,b)end end;local e=self:chunkid(a.source,self.MAXSRC)local b=string.format("%s:%d: %s",e,a.linenumber,b)if c then b=string.format("%s near "..self.LUA_QS,b,d(a,c))end;error(b)end;function c:syntaxerror(a,b)self:lexerror(a,b,a.t.token)end;function c:currIsNewline(a)return a.current=="\n"or a.current=="\r"end;function c:inclinenumber(a)local b=a.current;self:nextc(a)if self:currIsNewline(a)and a.current~=b then self:nextc(a)end;a.linenumber=a.linenumber+1;if a.linenumber>=self.MAX_INT then self:syntaxerror(a,"chunk has too many lines")end end;function c:setinput(a,b,c,d)if not b then b={}end;if not b.lookahead then b.lookahead={}end;if not b.t then b.t={}end;b.decpoint="."b.L=a;b.lookahead.token="TK_EOS"b.z=c;b.fs=nil;b.linenumber=1;b.lastline=1;b.source=d;self:nextc(b)end;function c:check_next(a,b)if not string.find(b,a.current,1,1)then return false end;self:save_and_next(a)return true end;function c:next(a)a.lastline=a.linenumber;if a.lookahead.token~="TK_EOS"then a.t.seminfo=a.lookahead.seminfo;a.t.token=a.lookahead.token;a.lookahead.token="TK_EOS"else a.t.token=self:llex(a,a.t)end end;function c:lookahead(a)a.lookahead.token=self:llex(a,a.lookahead)end;function c:nextc(b)local a=a:zgetc(b.z)b.current=a;return a end;function c:save(a,b)local c=a.buff;a.buff=c..b end;function c:save_and_next(a)self:save(a,a.current)return self:nextc(a)end;function c:str2d(a)local b=tonumber(a)if b then return b end;if string.lower(string.sub(a,1,2))=="0x"then b=tonumber(a,16)if b then return b end end;return nil end;function c:buffreplace(a,b,c)local d,e="",a.buff;for a=1,#e do local a=string.sub(e,a,a)if a==b then a=c end;d=d..a end;a.buff=d end;function c:trydecpoint(a,b)local c=a.decpoint;self:buffreplace(a,c,a.decpoint)local c=self:str2d(a.buff)b.seminfo=c;if not c then self:buffreplace(a,a.decpoint,".")self:lexerror(a,"malformed number","TK_NUMBER")end end;function c:read_numeral(a,b)repeat self:save_and_next(a)until string.find(a.current,"%D")and a.current~="."if self:check_next(a,"Ee")then self:check_next(a,"+-")end;while string.find(a.current,"^%w$")or a.current=="_"do self:save_and_next(a)end;self:buffreplace(a,".",a.decpoint)local c=self:str2d(a.buff)b.seminfo=c;if not c then self:trydecpoint(a,b)end end;function c:skip_sep(a)local b=0;local c=a.current;self:save_and_next(a)while a.current=="="do self:save_and_next(a)b=b+1 end;return a.current==c and b or-b-1 end;function c:read_long_string(a,b,c)local d=0;self:save_and_next(a)if self:currIsNewline(a)then self:inclinenumber(a)end;while true do local e=a.current;if e=="EOZ"then self:lexerror(a,b and"unfinished long string"or"unfinished long comment","TK_EOS")elseif e=="["then if self.LUA_COMPAT_LSTR then if self:skip_sep(a)==c then self:save_and_next(a)d=d+1;if self.LUA_COMPAT_LSTR==1 then if c==0 then self:lexerror(a,"nesting of [[...]] is deprecated","[")end end end end elseif e=="]"then if self:skip_sep(a)==c then self:save_and_next(a)if self.LUA_COMPAT_LSTR and self.LUA_COMPAT_LSTR==2 then d=d-1;if c==0 and d>=0 then break end end;break end elseif self:currIsNewline(a)then self:save(a,"\n")self:inclinenumber(a)if not b then a.buff=""end else if b then self:save_and_next(a)else self:nextc(a)end end end;if b then local c=3+c;b.seminfo=string.sub(a.buff,c,-c)end end;function c:read_string(a,b,c)self:save_and_next(a)while a.current~=b do local b=a.current;if b=="EOZ"then self:lexerror(a,"unfinished string","TK_EOS")elseif self:currIsNewline(a)then self:lexerror(a,"unfinished string","TK_STRING")elseif b=="\\"then b=self:nextc(a)if self:currIsNewline(a)then self:save(a,"\n")self:inclinenumber(a)elseif b~="EOZ"then local c=string.find("abfnrtv",b,1,1)if c then self:save(a,string.sub("\a\b\f\n\r\t\v",c,c))self:nextc(a)elseif not string.find(b,"%d")then self:save_and_next(a)else b,c=0,0;repeat b=10*b+a.current;self:nextc(a)c=c+1 until c>=3 or not string.find(a.current,"%d")if b>255 then self:lexerror(a,"escape sequence too large","TK_STRING")end;self:save(a,string.char(b))end end else self:save_and_next(a)end end;self:save_and_next(a)c.seminfo=string.sub(a.buff,2,-2)end;function c:llex(a,b)a.buff=""while true do local c=a.current;if self:currIsNewline(a)then self:inclinenumber(a)elseif c=="-"then c=self:nextc(a)if c~="-"then return"-"end;local b=-1;if self:nextc(a)=='['then b=self:skip_sep(a)a.buff=""end;if b>=0 then self:read_long_string(a,nil,b)a.buff=""else while not self:currIsNewline(a)and a.current~="EOZ"do self:nextc(a)end end elseif c=="["then local c=self:skip_sep(a)if c>=0 then self:read_long_string(a,b,c)return"TK_STRING"elseif c==-1 then return"["else self:lexerror(a,"invalid long string delimiter","TK_STRING")end elseif c=="="then c=self:nextc(a)if c~="="then return"="else self:nextc(a)return"TK_EQ"end elseif c=="<"then c=self:nextc(a)if c~="="then return"<"else self:nextc(a)return"TK_LE"end elseif c==">"then c=self:nextc(a)if c~="="then return">"else self:nextc(a)return"TK_GE"end elseif c=="~"then c=self:nextc(a)if c~="="then return"~"else self:nextc(a)return"TK_NE"end elseif c=="\""or c=="'"then self:read_string(a,c,b)return"TK_STRING"elseif c=="."then c=self:save_and_next(a)if self:check_next(a,".")then if self:check_next(a,".")then return"TK_DOTS"else return"TK_CONCAT"end elseif not string.find(c,"%d")then return"."else self:read_numeral(a,b)return"TK_NUMBER"end elseif c=="EOZ"then return"TK_EOS"else if string.find(c,"%s")then self:nextc(a)elseif string.find(c,"%d")then self:read_numeral(a,b)return"TK_NUMBER"elseif string.find(c,"[_%a]")then repeat c=self:save_and_next(a)until c=="EOZ"or not string.find(c,"[_%w]")local a=a.buff;local c=self.enums[a]if c then return c end;b.seminfo=a;return"TK_NAME"else self:nextc(a)return c end end end end;d.OpMode={iABC=0,iABx=1,iAsBx=2}d.SIZE_C=9;d.SIZE_B=9;d.SIZE_Bx=d.SIZE_C+d.SIZE_B;d.SIZE_A=8;d.SIZE_OP=6;d.POS_OP=0;d.POS_A=d.POS_OP+d.SIZE_OP;d.POS_C=d.POS_A+d.SIZE_A;d.POS_B=d.POS_C+d.SIZE_C;d.POS_Bx=d.POS_C;d.MAXARG_Bx=math.ldexp(1,d.SIZE_Bx)-1;d.MAXARG_sBx=math.floor(d.MAXARG_Bx/2)d.MAXARG_A=math.ldexp(1,d.SIZE_A)-1;d.MAXARG_B=math.ldexp(1,d.SIZE_B)-1;d.MAXARG_C=math.ldexp(1,d.SIZE_C)-1;function d:GET_OPCODE(a)return self.ROpCode[a.OP]end;function d:SET_OPCODE(a,b)a.OP=self.OpCode[b]end;function d:GETARG_A(a)return a.A end;function d:SETARG_A(a,b)a.A=b end;function d:GETARG_B(a)return a.B end;function d:SETARG_B(a,b)a.B=b end;function d:GETARG_C(a)return a.C end;function d:SETARG_C(a,b)a.C=b end;function d:GETARG_Bx(a)return a.Bx end;function d:SETARG_Bx(a,b)a.Bx=b end;function d:GETARG_sBx(a)return a.Bx-self.MAXARG_sBx end;function d:SETARG_sBx(a,b)a.Bx=b+self.MAXARG_sBx end;function d:CREATE_ABC(a,b,c,d)return{OP=self.OpCode[a],A=b,B=c,C=d}end;function d:CREATE_ABx(a,b,c)return{OP=self.OpCode[a],A=b,Bx=c}end;function d:CREATE_Inst(a)local b=a%64;a=(a-b)/64;local c=a%256;a=(a-c)/256;return self:CREATE_ABx(b,c,a)end;function d:Instruction(a)if a.Bx then a.C=a.Bx%512;a.B=(a.Bx-a.C)/512 end;local b=a.A*64+a.OP;local c=b%256;b=a.C*64+(b-c)/256;local d=b%256;b=a.B*128+(b-d)/256;local a=b%256;local b=(b-a)/256;return string.char(c,d,a,b)end;function d:DecodeInst(a)local b=string.byte;local c={}local d=b(a,1)local e=d%64;c.OP=e;d=b(a,2)*4+(d-e)/64;local f=d%256;c.A=f;d=b(a,3)*4+(d-f)/256;local f=d%512;c.C=f;c.B=b(a,4)*2+(d-f)/512;local a=self.OpMode[tonumber(string.sub(self.opmodes[e+1],7,7))]if a~="iABC"then c.Bx=c.B*512+c.C end;return c end;d.BITRK=math.ldexp(1,d.SIZE_B-1)function d:ISK(a)return a>=self.BITRK end;function d:INDEXK(a)return x-self.BITRK end;d.MAXINDEXRK=d.BITRK-1;function d:RKASK(a)return a+self.BITRK end;d.NO_REG=d.MAXARG_A;d.opnames={}d.OpCode={}d.ROpCode={}local i=0;for a in string.gmatch("MOVE LOADK LOADBOOL LOADNIL GETUPVAL\nGETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE\nNEWTABLE SELF ADD SUB MUL\nDIV MOD POW UNM NOT\nLEN CONCAT JMP EQ LT\nLE TEST TESTSET CALL TAILCALL\nRETURN FORLOOP FORPREP TFORLOOP SETLIST\nCLOSE CLOSURE VARARG\n","%S+")do local b="OP_"..a;d.opnames[i]=a;d.OpCode[b]=i;d.ROpCode[i]=b;i=i+1 end;d.NUM_OPCODES=i;d.OpArgMask={OpArgN=0,OpArgU=1,OpArgR=2,OpArgK=3}function d:getOpMode(a)return self.opmodes[self.OpCode[a]]%4 end;function d:getBMode(a)return math.floor(self.opmodes[self.OpCode[a]]/16)%4 end;function d:getCMode(a)return math.floor(self.opmodes[self.OpCode[a]]/4)%4 end;function d:testAMode(a)return math.floor(self.opmodes[self.OpCode[a]]/64)%2 end;function d:testTMode(a)return math.floor(self.opmodes[self.OpCode[a]]/128)end;d.LFIELDS_PER_FLUSH=50;local function i(a,b,c,e,f)local d=d;return a*128+b*64+d.OpArgMask[c]*16+d.OpArgMask[e]*4+d.OpMode[f]end;d.opmodes={i(0,1,"OpArgK","OpArgN","iABx"),i(0,1,"OpArgU","OpArgU","iABC"),i(0,1,"OpArgR","OpArgN","iABC"),i(0,1,"OpArgU","OpArgN","iABC"),i(0,1,"OpArgK","OpArgN","iABx"),i(0,1,"OpArgR","OpArgK","iABC"),i(0,0,"OpArgK","OpArgN","iABx"),i(0,0,"OpArgU","OpArgN","iABC"),i(0,0,"OpArgK","OpArgK","iABC"),i(0,1,"OpArgU","OpArgU","iABC"),i(0,1,"OpArgR","OpArgK","iABC"),i(0,1,"OpArgK","OpArgK","iABC"),i(0,1,"OpArgK","OpArgK","iABC"),i(0,1,"OpArgK","OpArgK","iABC"),i(0,1,"OpArgK","OpArgK","iABC"),i(0,1,"OpArgK","OpArgK","iABC"),i(0,1,"OpArgK","OpArgK","iABC"),i(0,1,"OpArgR","OpArgN","iABC"),i(0,1,"OpArgR","OpArgN","iABC"),i(0,1,"OpArgR","OpArgN","iABC"),i(0,1,"OpArgR","OpArgR","iABC"),i(0,0,"OpArgR","OpArgN","iAsBx"),i(1,0,"OpArgK","OpArgK","iABC"),i(1,0,"OpArgK","OpArgK","iABC"),i(1,0,"OpArgK","OpArgK","iABC"),i(1,1,"OpArgR","OpArgU","iABC"),i(1,1,"OpArgR","OpArgU","iABC"),i(0,1,"OpArgU","OpArgU","iABC"),i(0,1,"OpArgU","OpArgU","iABC"),i(0,0,"OpArgU","OpArgN","iABC"),i(0,1,"OpArgR","OpArgN","iAsBx"),i(0,1,"OpArgR","OpArgN","iAsBx"),i(1,0,"OpArgN","OpArgU","iABC"),i(0,0,"OpArgU","OpArgU","iABC"),i(0,0,"OpArgN","OpArgN","iABC"),i(0,1,"OpArgU","OpArgN","iABx"),i(0,1,"OpArgU","OpArgN","iABC")}d.opmodes[0]=i(0,1,"OpArgR","OpArgN","iABC")e.LUA_SIGNATURE="\27Lua"e.LUA_TNUMBER=3;e.LUA_TSTRING=4;e.LUA_TNIL=0;e.LUA_TBOOLEAN=1;e.LUA_TNONE=-1;e.LUAC_VERSION=81;e.LUAC_FORMAT=0;e.LUAC_HEADERSIZE=12;function e:make_setS()local a={}a.data=""local b=function(a,b)if not a then return 0 end;b.data=b.data..a;return 0 end;return b,a end;function e:make_setF(a)local b={}b.h=io.open(a,"wb")if not b.h then return nil end;local a=function(a,b)if not b.h then return 0 end;if not a then if b.h:close()then return 0 end else if b.h:write(a)then return 0 end end;return 1 end;return a,b end;function e:ttype(a)local a=type(a.value)if a=="number"then return self.LUA_TNUMBER elseif a=="string"then return self.LUA_TSTRING elseif a=="nil"then return self.LUA_TNIL elseif a=="boolean"then return self.LUA_TBOOLEAN else return self.LUA_TNONE end end;function e:from_double(a)local function b(a)local b=a%256;return(a-b)/256,string.char(b)end;local c=0;if a<0 then c=1;a=-a end;local d,e=math.frexp(a)if a==0 then d,e=0,0 elseif a==1/0 then d,e=0,2047 else d=(d*2-1)*math.ldexp(0.5,53)e=e+1022 end;local f,g=""a=math.floor(d)for c=1,6 do a,g=b(a)f=f..g end;a,g=b(e*16+a)f=f..g;a,g=b(c*128+a)f=f..g;return f end;function e:from_int(a)local b=""a=math.floor(a)if a<0 then a=4294967296+a end;for c=1,4 do local c=a%256;b=b..string.char(c)a=math.floor(a/256)end;return b end;function e:DumpBlock(a,b)if b.status==0 then b.status=b.write(a,b.data)end end;function e:DumpChar(a,b)self:DumpBlock(string.char(a),b)end;function e:DumpInt(a,b)self:DumpBlock(self:from_int(a),b)end;function e:DumpSizeT(a,b)self:DumpBlock(self:from_int(a),b)if g==8 then self:DumpBlock(self:from_int(0),b)end end;function e:DumpNumber(a,b)self:DumpBlock(self:from_double(a),b)end;function e:DumpString(a,b)if a==nil then self:DumpSizeT(0,b)else a=a.."\0"self:DumpSizeT(#a,b)self:DumpBlock(a,b)end end;function e:DumpCode(a,b)local c=a.sizecode;self:DumpInt(c,b)for c=0,c-1 do self:DumpBlock(d:Instruction(a.code[c]),b)end end;function e:DumpConstants(a,b)local c=a.sizek;self:DumpInt(c,b)for c=0,c-1 do local a=a.k[c]local c=self:ttype(a)self:DumpChar(c,b)if c==self.LUA_TNIL then elseif c==self.LUA_TBOOLEAN then self:DumpChar(a.value and 1 or 0,b)elseif c==self.LUA_TNUMBER then self:DumpNumber(a.value,b)elseif c==self.LUA_TSTRING then self:DumpString(a.value,b)else end end;c=a.sizep;self:DumpInt(c,b)for c=0,c-1 do self:DumpFunction(a.p[c],a.source,b)end end;function e:DumpDebug(a,b)local c;c=b.strip and 0 or a.sizelineinfo;self:DumpInt(c,b)for c=0,c-1 do self:DumpInt(a.lineinfo[c],b)end;c=b.strip and 0 or a.sizelocvars;self:DumpInt(c,b)for c=0,c-1 do self:DumpString(a.locvars[c].varname,b)self:DumpInt(a.locvars[c].startpc,b)self:DumpInt(a.locvars[c].endpc,b)end;c=b.strip and 0 or a.sizeupvalues;self:DumpInt(c,b)for c=0,c-1 do self:DumpString(a.upvalues[c],b)end end;function e:DumpFunction(a,b,c)local d=a.source;if d==b or c.strip then d=nil end;self:DumpString(d,c)self:DumpInt(a.lineDefined,c)self:DumpInt(a.lastlinedefined,c)self:DumpChar(a.nups,c)self:DumpChar(a.numparams,c)self:DumpChar(a.is_vararg,c)self:DumpChar(a.maxstacksize,c)self:DumpCode(a,c)self:DumpConstants(a,c)self:DumpDebug(a,c)end;function e:DumpHeader(a)local b=self:header()assert(#b==self.LUAC_HEADERSIZE)self:DumpBlock(b,a)end;function e:header()local a=1;return self.LUA_SIGNATURE..string.char(self.LUAC_VERSION,self.LUAC_FORMAT,a,4,g,4,8,0)end;function e:dump(a,b,c,d,e)local f={}f.L=a;f.write=c;f.data=d;f.strip=e;f.status=0;self:DumpHeader(f)self:DumpFunction(b,nil,f)f.write(nil,f.data)return f.status end;f.MAXSTACK=250;function f:ttisnumber(a)if a then return type(a.value)=="number"else return false end end;function f:nvalue(a)return a.value end;function f:setnilvalue(a)a.value=nil end;function f:setsvalue(a,b)a.value=b end;f.setnvalue=f.setsvalue;f.sethvalue=f.setsvalue;f.setbvalue=f.setsvalue;function f:numadd(a,b)return a+b end;function f:numsub(a,b)return a-b end;function f:nummul(a,b)return a*b end;function f:numdiv(a,b)return a/b end;function f:nummod(a,b)return a%b end;function f:numpow(a,b)return a^b end;function f:numunm(a)return-a end;function f:numisnan(a)return not a==a end;f.NO_JUMP=-1;f.BinOpr={OPR_ADD=0,OPR_SUB=1,OPR_MUL=2,OPR_DIV=3,OPR_MOD=4,OPR_POW=5,OPR_CONCAT=6,OPR_NE=7,OPR_EQ=8,OPR_LT=9,OPR_LE=10,OPR_GT=11,OPR_GE=12,OPR_AND=13,OPR_OR=14,OPR_NOBINOPR=15}f.UnOpr={OPR_MINUS=0,OPR_NOT=1,OPR_LEN=2,OPR_NOUNOPR=3}function f:getcode(a,b)return a.f.code[b.info]end;function f:codeAsBx(a,b,c,e)return self:codeABx(a,b,c,e+d.MAXARG_sBx)end;function f:setmultret(a,c)self:setreturns(a,c,b.LUA_MULTRET)end;function f:hasjumps(a)return a.t~=a.f end;function f:isnumeral(a)return a.k=="VKNUM"and a.t==self.NO_JUMP and a.f==self.NO_JUMP end;function f:_nil(a,b,c)if a.pc>a.lasttarget then if a.pc==0 then if b>=a.nactvar then return end else local a=a.f.code[a.pc-1]if d:GET_OPCODE(a)=="OP_LOADNIL"then local e=d:GETARG_A(a)local f=d:GETARG_B(a)if e<=b and b<=f+1 then if b+c-1>f then d:SETARG_B(a,b+c-1)end;return end end end end;self:codeABC(a,"OP_LOADNIL",b,b+c-1,0)end;function f:jump(a)local b=a.jpc;a.jpc=self.NO_JUMP;local c=self:codeAsBx(a,"OP_JMP",0,self.NO_JUMP)c=self:concat(a,c,b)return c end;function f:ret(a,b,c)self:codeABC(a,"OP_RETURN",b,c+1,0)end;function f:condjump(a,b,c,d,e)self:codeABC(a,b,c,d,e)return self:jump(a)end;function f:fixjump(a,b,e)local f=a.f.code[b]local b=e-(b+1)h(e~=self.NO_JUMP)if math.abs(b)>d.MAXARG_sBx then c:syntaxerror(a.ls,"control structure too long")end;d:SETARG_sBx(f,b)end;function f:getlabel(a)a.lasttarget=a.pc;return a.pc end;function f:getjump(a,b)local a=d:GETARG_sBx(a.f.code[b])if a==self.NO_JUMP then return self.NO_JUMP else return b+1+a end end;function f:getjumpcontrol(a,b)local c=a.f.code[b]local a=a.f.code[b-1]if b>=1 and d:testTMode(d:GET_OPCODE(a))~=0 then return a else return c end end;function f:need_value(a,b)while b~=self.NO_JUMP do local c=self:getjumpcontrol(a,b)if d:GET_OPCODE(c)~="OP_TESTSET"then return true end;b=self:getjump(a,b)end;return false end;function f:patchtestreg(a,b,c)local a=self:getjumpcontrol(a,b)if d:GET_OPCODE(a)~="OP_TESTSET"then return false end;if c~=d.NO_REG and c~=d:GETARG_B(a)then d:SETARG_A(a,c)else d:SET_OPCODE(a,"OP_TEST")local b=d:GETARG_B(a)d:SETARG_A(a,b)d:SETARG_B(a,0)end;return true end;function f:removevalues(a,b)while b~=self.NO_JUMP do self:patchtestreg(a,b,d.NO_REG)b=self:getjump(a,b)end end;function f:patchlistaux(a,b,c,d,e)while b~=self.NO_JUMP do local f=self:getjump(a,b)if self:patchtestreg(a,b,d)then self:fixjump(a,b,c)else self:fixjump(a,b,e)end;b=f end end;function f:dischargejpc(a)self:patchlistaux(a,a.jpc,a.pc,d.NO_REG,a.pc)a.jpc=self.NO_JUMP end;function f:patchlist(a,b,c)if c==a.pc then self:patchtohere(a,b)else h(c<a.pc)self:patchlistaux(a,b,c,d.NO_REG,c)end end;function f:patchtohere(a,b)self:getlabel(a)a.jpc=self:concat(a,a.jpc,b)end;function f:concat(a,b,c)if c==self.NO_JUMP then return b elseif b==self.NO_JUMP then return c else local b=b;local d=self:getjump(a,b)while d~=self.NO_JUMP do b=d;d=self:getjump(a,b)end;self:fixjump(a,b,c)end;return b end;function f:checkstack(a,b)local b=a.freereg+b;if b>a.f.maxstacksize then if b>=self.MAXSTACK then c:syntaxerror(a.ls,"function or expression too complex")end;a.f.maxstacksize=b end end;function f:reserveregs(a,b)self:checkstack(a,b)a.freereg=a.freereg+b end;function f:freereg(a,b)if not d:ISK(b)and b>=a.nactvar then a.freereg=a.freereg-1;h(b==a.freereg)end end;function f:freeexp(a,b)if b.k=="VNONRELOC"then self:freereg(a,b.info)end end;function f:addk(a,c,e)local f=a.L;local g=a.h[c.value]local h=a.f;if self:ttisnumber(g)then return self:nvalue(g)else g={}self:setnvalue(g,a.nk)a.h[c.value]=g;b:growvector(f,h.k,a.nk,h.sizek,nil,d.MAXARG_Bx,"constant table overflow")h.k[a.nk]=e;local b=a.nk;a.nk=a.nk+1;return b end end;function f:stringK(a,b)local c={}self:setsvalue(c,b)return self:addk(a,c,c)end;function f:numberK(a,b)local c={}self:setnvalue(c,b)return self:addk(a,c,c)end;function f:boolK(a,b)local c={}self:setbvalue(c,b)return self:addk(a,c,c)end;function f:nilK(a)local b,c={},{}self:setnilvalue(c)self:sethvalue(b,a.h)return self:addk(a,b,c)end;function f:setreturns(a,b,c)if b.k=="VCALL"then d:SETARG_C(self:getcode(a,b),c+1)elseif b.k=="VVARARG"then d:SETARG_B(self:getcode(a,b),c+1)d:SETARG_A(self:getcode(a,b),a.freereg)f:reserveregs(a,1)end end;function f:setoneret(a,b)if b.k=="VCALL"then b.k="VNONRELOC"b.info=d:GETARG_A(self:getcode(a,b))elseif b.k=="VVARARG"then d:SETARG_B(self:getcode(a,b),2)b.k="VRELOCABLE"end end;function f:dischargevars(a,b)local c=b.k;if c=="VLOCAL"then b.k="VNONRELOC"elseif c=="VUPVAL"then b.info=self:codeABC(a,"OP_GETUPVAL",0,b.info,0)b.k="VRELOCABLE"elseif c=="VGLOBAL"then b.info=self:codeABx(a,"OP_GETGLOBAL",0,b.info)b.k="VRELOCABLE"elseif c=="VINDEXED"then self:freereg(a,b.aux)self:freereg(a,b.info)b.info=self:codeABC(a,"OP_GETTABLE",0,b.info,b.aux)b.k="VRELOCABLE"elseif c=="VVARARG"or c=="VCALL"then self:setoneret(a,b)else end end;function f:code_label(a,b,c,d)self:getlabel(a)return self:codeABC(a,"OP_LOADBOOL",b,c,d)end;function f:discharge2reg(a,b,c)self:dischargevars(a,b)local e=b.k;if e=="VNIL"then self:_nil(a,c,1)elseif e=="VFALSE"or e=="VTRUE"then self:codeABC(a,"OP_LOADBOOL",c,b.k=="VTRUE"and 1 or 0,0)elseif e=="VK"then self:codeABx(a,"OP_LOADK",c,b.info)elseif e=="VKNUM"then self:codeABx(a,"OP_LOADK",c,self:numberK(a,b.nval))elseif e=="VRELOCABLE"then local a=self:getcode(a,b)d:SETARG_A(a,c)elseif e=="VNONRELOC"then if c~=b.info then self:codeABC(a,"OP_MOVE",c,b.info,0)end else h(b.k=="VVOID"or b.k=="VJMP")return end;b.info=c;b.k="VNONRELOC"end;function f:discharge2anyreg(a,b)if b.k~="VNONRELOC"then self:reserveregs(a,1)self:discharge2reg(a,b,a.freereg-1)end end;function f:exp2reg(a,b,c)self:discharge2reg(a,b,c)if b.k=="VJMP"then b.t=self:concat(a,b.t,b.info)end;if self:hasjumps(b)then local d;local e=self.NO_JUMP;local f=self.NO_JUMP;if self:need_value(a,b.t)or self:need_value(a,b.f)then local b=b.k=="VJMP"and self.NO_JUMP or self:jump(a)e=self:code_label(a,c,0,1)f=self:code_label(a,c,1,0)self:patchtohere(a,b)end;d=self:getlabel(a)self:patchlistaux(a,b.f,d,c,e)self:patchlistaux(a,b.t,d,c,f)end;b.f,b.t=self.NO_JUMP,self.NO_JUMP;b.info=c;b.k="VNONRELOC"end;function f:exp2nextreg(a,b)self:dischargevars(a,b)self:freeexp(a,b)self:reserveregs(a,1)self:exp2reg(a,b,a.freereg-1)end;function f:exp2anyreg(a,b)self:dischargevars(a,b)if b.k=="VNONRELOC"then if not self:hasjumps(b)then return b.info end;if b.info>=a.nactvar then self:exp2reg(a,b,b.info)return b.info end end;self:exp2nextreg(a,b)return b.info end;function f:exp2val(a,b)if self:hasjumps(b)then self:exp2anyreg(a,b)else self:dischargevars(a,b)end end;function f:exp2RK(a,b)self:exp2val(a,b)local c=b.k;if c=="VKNUM"or c=="VTRUE"or c=="VFALSE"or c=="VNIL"then if a.nk<=d.MAXINDEXRK then if b.k=="VNIL"then b.info=self:nilK(a)else b.info=b.k=="VKNUM"and self:numberK(a,b.nval)or self:boolK(a,b.k=="VTRUE")end;b.k="VK"return d:RKASK(b.info)end elseif c=="VK"then if b.info<=d.MAXINDEXRK then return d:RKASK(b.info)end else end;return self:exp2anyreg(a,b)end;function f:storevar(a,b,c)local d=b.k;if d=="VLOCAL"then self:freeexp(a,c)self:exp2reg(a,c,b.info)return elseif d=="VUPVAL"then local c=self:exp2anyreg(a,c)self:codeABC(a,"OP_SETUPVAL",c,b.info,0)elseif d=="VGLOBAL"then local c=self:exp2anyreg(a,c)self:codeABx(a,"OP_SETGLOBAL",c,b.info)elseif d=="VINDEXED"then local c=self:exp2RK(a,c)self:codeABC(a,"OP_SETTABLE",b.info,b.aux,c)else h(0)end;self:freeexp(a,c)end;function f:_self(a,b,c)self:exp2anyreg(a,b)self:freeexp(a,b)local d=a.freereg;self:reserveregs(a,2)self:codeABC(a,"OP_SELF",d,b.info,self:exp2RK(a,c))self:freeexp(a,c)b.info=d;b.k="VNONRELOC"end;function f:invertjump(a,b)local a=self:getjumpcontrol(a,b.info)h(d:testTMode(d:GET_OPCODE(a))~=0 and d:GET_OPCODE(a)~="OP_TESTSET"and d:GET_OPCODE(a)~="OP_TEST")d:SETARG_A(a,d:GETARG_A(a)==0 and 1 or 0)end;function f:jumponcond(a,b,c)if b.k=="VRELOCABLE"then local b=self:getcode(a,b)if d:GET_OPCODE(b)=="OP_NOT"then a.pc=a.pc-1;return self:condjump(a,"OP_TEST",d:GETARG_B(b),0,c and 0 or 1)end end;self:discharge2anyreg(a,b)self:freeexp(a,b)return self:condjump(a,"OP_TESTSET",d.NO_REG,b.info,c and 1 or 0)end;function f:goiftrue(a,b)local c;self:dischargevars(a,b)local d=b.k;if d=="VK"or d=="VKNUM"or d=="VTRUE"then c=self.NO_JUMP elseif d=="VFALSE"then c=self:jump(a)elseif d=="VJMP"then self:invertjump(a,b)c=b.info else c=self:jumponcond(a,b,false)end;b.f=self:concat(a,b.f,c)self:patchtohere(a,b.t)b.t=self.NO_JUMP end;function f:goiffalse(a,b)local c;self:dischargevars(a,b)local d=b.k;if d=="VNIL"or d=="VFALSE"then c=self.NO_JUMP elseif d=="VTRUE"then c=self:jump(a)elseif d=="VJMP"then c=b.info else c=self:jumponcond(a,b,true)end;b.t=self:concat(a,b.t,c)self:patchtohere(a,b.f)b.f=self.NO_JUMP end;function f:codenot(a,b)self:dischargevars(a,b)local c=b.k;if c=="VNIL"or c=="VFALSE"then b.k="VTRUE"elseif c=="VK"or c=="VKNUM"or c=="VTRUE"then b.k="VFALSE"elseif c=="VJMP"then self:invertjump(a,b)elseif c=="VRELOCABLE"or c=="VNONRELOC"then self:discharge2anyreg(a,b)self:freeexp(a,b)b.info=self:codeABC(a,"OP_NOT",0,b.info,0)b.k="VRELOCABLE"else h(0)end;b.f,b.t=b.t,b.f;self:removevalues(a,b.f)self:removevalues(a,b.t)end;function f:indexed(a,b,c)b.aux=self:exp2RK(a,c)b.k="VINDEXED"end;function f:constfolding(a,b,c)local d;if not self:isnumeral(b)or not self:isnumeral(c)then return false end;local e=b.nval;local c=c.nval;if a=="OP_ADD"then d=self:numadd(e,c)elseif a=="OP_SUB"then d=self:numsub(e,c)elseif a=="OP_MUL"then d=self:nummul(e,c)elseif a=="OP_DIV"then if c==0 then return false end;d=self:numdiv(e,c)elseif a=="OP_MOD"then if c==0 then return false end;d=self:nummod(e,c)elseif a=="OP_POW"then d=self:numpow(e,c)elseif a=="OP_UNM"then d=self:numunm(e)elseif a=="OP_LEN"then return false else h(0)d=0 end;if self:numisnan(d)then return false end;b.nval=d;return true end;function f:codearith(a,b,c,d)if self:constfolding(b,c,d)then return else local e=b~="OP_UNM"and b~="OP_LEN"and self:exp2RK(a,d)or 0;local f=self:exp2RK(a,c)if f>e then self:freeexp(a,c)self:freeexp(a,d)else self:freeexp(a,d)self:freeexp(a,c)end;c.info=self:codeABC(a,b,0,f,e)c.k="VRELOCABLE"end end;function f:codecomp(a,b,c,d,e)local f=self:exp2RK(a,d)local g=self:exp2RK(a,e)self:freeexp(a,e)self:freeexp(a,d)if c==0 and b~="OP_EQ"then f,g=g,f;c=1 end;d.info=self:condjump(a,b,c,f,g)d.k="VJMP"end;function f:prefix(a,b,c)local d={}d.t,d.f=self.NO_JUMP,self.NO_JUMP;d.k="VKNUM"d.nval=0;if b=="OPR_MINUS"then if not self:isnumeral(c)then self:exp2anyreg(a,c)end;self:codearith(a,"OP_UNM",c,d)elseif b=="OPR_NOT"then self:codenot(a,c)elseif b=="OPR_LEN"then self:exp2anyreg(a,c)self:codearith(a,"OP_LEN",c,d)else h(0)end end;function f:infix(a,b,c)if b=="OPR_AND"then self:goiftrue(a,c)elseif b=="OPR_OR"then self:goiffalse(a,c)elseif b=="OPR_CONCAT"then self:exp2nextreg(a,c)elseif b=="OPR_ADD"or b=="OPR_SUB"or b=="OPR_MUL"or b=="OPR_DIV"or b=="OPR_MOD"or b=="OPR_POW"then if not self:isnumeral(c)then self:exp2RK(a,c)end else self:exp2RK(a,c)end end;f.arith_op={OPR_ADD="OP_ADD",OPR_SUB="OP_SUB",OPR_MUL="OP_MUL",OPR_DIV="OP_DIV",OPR_MOD="OP_MOD",OPR_POW="OP_POW"}f.comp_op={OPR_EQ="OP_EQ",OPR_NE="OP_EQ",OPR_LT="OP_LT",OPR_LE="OP_LE",OPR_GT="OP_LT",OPR_GE="OP_LE"}f.comp_cond={OPR_EQ=1,OPR_NE=0,OPR_LT=1,OPR_LE=1,OPR_GT=0,OPR_GE=0}function f:posfix(a,b,c,e)local function f(a,b)a.k=b.k;a.info=b.info;a.aux=b.aux;a.nval=b.nval;a.t=b.t;a.f=b.f end;if b=="OPR_AND"then h(c.t==self.NO_JUMP)self:dischargevars(a,e)e.f=self:concat(a,e.f,c.f)f(c,e)elseif b=="OPR_OR"then h(c.f==self.NO_JUMP)self:dischargevars(a,e)e.t=self:concat(a,e.t,c.t)f(c,e)elseif b=="OPR_CONCAT"then self:exp2val(a,e)if e.k=="VRELOCABLE"and d:GET_OPCODE(self:getcode(a,e))=="OP_CONCAT"then h(c.info==d:GETARG_B(self:getcode(a,e))-1)self:freeexp(a,c)d:SETARG_B(self:getcode(a,e),c.info)c.k="VRELOCABLE"c.info=e.info else self:exp2nextreg(a,e)self:codearith(a,"OP_CONCAT",c,e)end else local d=self.arith_op[b]if d then self:codearith(a,d,c,e)else local d=self.comp_op[b]if d then self:codecomp(a,d,self.comp_cond[b],c,e)else h(0)end end end end;function f:fixline(a,b)a.f.lineinfo[a.pc-1]=b end;function f:code(a,c,d)local e=a.f;self:dischargejpc(a)b:growvector(a.L,e.code,a.pc,e.sizecode,nil,b.MAX_INT,"code size overflow")e.code[a.pc]=c;b:growvector(a.L,e.lineinfo,a.pc,e.sizelineinfo,nil,b.MAX_INT,"code size overflow")e.lineinfo[a.pc]=d;local b=a.pc;a.pc=a.pc+1;return b end;function f:codeABC(a,b,c,e,f)h(d:getOpMode(b)==d.OpMode.iABC)h(d:getBMode(b)~=d.OpArgMask.OpArgN or e==0)h(d:getCMode(b)~=d.OpArgMask.OpArgN or f==0)return self:code(a,d:CREATE_ABC(b,c,e,f),a.ls.lastline)end;function f:codeABx(a,b,c,e)h(d:getOpMode(b)==d.OpMode.iABx or d:getOpMode(b)==d.OpMode.iAsBx)h(d:getCMode(b)==d.OpArgMask.OpArgN)return self:code(a,d:CREATE_ABx(b,c,e),a.ls.lastline)end;function f:setlist(a,c,e,f)local e=math.floor((e-1)/d.LFIELDS_PER_FLUSH)+1;local b=f==b.LUA_MULTRET and 0 or f;h(f~=0)if e<=d.MAXARG_C then self:codeABC(a,"OP_SETLIST",c,b,e)else self:codeABC(a,"OP_SETLIST",c,b,0)self:code(a,d:CREATE_Inst(e),a.ls.lastline)end;a.freereg=c+1 end;b.LUA_QS=c.LUA_QS or"'%s'"b.SHRT_MAX=32767;b.LUAI_MAXVARS=200;b.LUAI_MAXUPVALUES=60;b.MAX_INT=c.MAX_INT or 2147483645;b.LUAI_MAXCCALLS=200;b.VARARG_HASARG=1;b.HASARG_MASK=2;b.VARARG_ISVARARG=2;b.VARARG_NEEDSARG=4;b.LUA_MULTRET=-1;function b:LUA_QL(a)return"'"..a.."'"end;function b:growvector(a,a,a,b,b,b,c)if a>=b then error(c)end end;function b:newproto(a)local a={}a.k={}a.sizek=0;a.p={}a.sizep=0;a.code={}a.sizecode=0;a.sizelineinfo=0;a.sizeupvalues=0;a.nups=0;a.upvalues={}a.numparams=0;a.is_vararg=0;a.maxstacksize=0;a.lineinfo={}a.sizelocvars=0;a.locvars={}a.lineDefined=0;a.lastlinedefined=0;a.source=nil;return a end;function b:int2fb(a)local b=0;while a>=16 do a=math.floor((a+1)/2)b=b+1 end;if a<8 then return a else return(b+1)*8+a-8 end end;function b:hasmultret(a)return a=="VCALL"or a=="VVARARG"end;function b:getlocvar(a,b)return a.f.locvars[a.actvar[b]]end;function b:checklimit(a,b,c,d)if b>c then self:errorlimit(a,c,d)end end;function b:anchor_token(a)if a.t.token=="TK_NAME"or a.t.token=="TK_STRING"then end end;function b:error_expected(a,b)c:syntaxerror(a,string.format(self.LUA_QS.." expected",c:token2str(a,b)))end;function b:errorlimit(a,b,d)local b=a.f.linedefined==0 and string.format("main function has more than %d %s",b,d)or string.format("function at line %d has more than %d %s",a.f.linedefined,b,d)c:lexerror(a.ls,b,0)end;function b:testnext(a,b)if a.t.token==b then c:next(a)return true else return false end end;function b:check(a,b)if a.t.token~=b then self:error_expected(a,b)end end;function b:checknext(a,b)self:check(a,b)c:next(a)end;function b:check_condition(a,b,d)if not b then c:syntaxerror(a,d)end end;function b:check_match(a,b,d,e)if not self:testnext(a,b)then if e==a.linenumber then self:error_expected(a,b)else c:syntaxerror(a,string.format(self.LUA_QS.." expected (to close "..self.LUA_QS.." at line %d)",c:token2str(a,b),c:token2str(a,d),e))end end end;function b:str_checkname(a)self:check(a,"TK_NAME")local b=a.t.seminfo;c:next(a)return b end;function b:init_exp(a,b,c)a.f,a.t=f.NO_JUMP,f.NO_JUMP;a.k=b;a.info=c end;function b:codestring(a,b,c)self:init_exp(b,"VK",f:stringK(a.fs,c))end;function b:checkname(a,b)self:codestring(a,b,self:str_checkname(a))end;function b:registerlocalvar(a,b)local c=a.fs;local d=c.f;self:growvector(a.L,d.locvars,c.nlocvars,d.sizelocvars,nil,self.SHRT_MAX,"too many local variables")d.locvars[c.nlocvars]={}d.locvars[c.nlocvars].varname=b;local a=c.nlocvars;c.nlocvars=c.nlocvars+1;return a end;function b:new_localvarliteral(a,b,c)self:new_localvar(a,b,c)end;function b:new_localvar(a,b,c)local d=a.fs;self:checklimit(d,d.nactvar+c+1,self.LUAI_MAXVARS,"local variables")d.actvar[d.nactvar+c]=self:registerlocalvar(a,b)end;function b:adjustlocalvars(a,b)local a=a.fs;a.nactvar=a.nactvar+b;for b=b,1,-1 do self:getlocvar(a,a.nactvar-b).startpc=a.pc end end;function b:removevars(a,b)local a=a.fs;while a.nactvar>b do a.nactvar=a.nactvar-1;self:getlocvar(a,a.nactvar).endpc=a.pc end end;function b:indexupvalue(a,b,c)local d=a.f;for e=0,d.nups-1 do if a.upvalues[e].k==c.k and a.upvalues[e].info==c.info then h(d.upvalues[e]==b)return e end end;self:checklimit(a,d.nups+1,self.LUAI_MAXUPVALUES,"upvalues")self:growvector(a.L,d.upvalues,d.nups,d.sizeupvalues,nil,self.MAX_INT,"")d.upvalues[d.nups]=b;h(c.k=="VLOCAL"or c.k=="VUPVAL")a.upvalues[d.nups]={k=c.k,info=c.info}local a=d.nups;d.nups=d.nups+1;return a end;function b:searchvar(a,b)for c=a.nactvar-1,0,-1 do if b==self:getlocvar(a,c).varname then return c end end;return-1 end;function b:markupval(a,b)local a=a.bl;while a and a.nactvar>b do a=a.previous end;if a then a.upval=true end end;function b:singlevaraux(a,b,c,e)if a==nil then self:init_exp(c,"VGLOBAL",d.NO_REG)return"VGLOBAL"else local d=self:searchvar(a,b)if d>=0 then self:init_exp(c,"VLOCAL",d)if e==0 then self:markupval(a,d)end;return"VLOCAL"else if self:singlevaraux(a.prev,b,c,0)=="VGLOBAL"then return"VGLOBAL"end;c.info=self:indexupvalue(a,b,c)c.k="VUPVAL"return"VUPVAL"end end end;function b:singlevar(a,b)local c=self:str_checkname(a)local a=a.fs;if self:singlevaraux(a,c,b,1)=="VGLOBAL"then b.info=f:stringK(a,c)end end;function b:adjust_assign(a,b,c,d)local a=a.fs;local b=b-c;if self:hasmultret(d.k)then b=b+1;if b<=0 then b=0 end;f:setreturns(a,d,b)if b>1 then f:reserveregs(a,b-1)end else if d.k~="VVOID"then f:exp2nextreg(a,d)end;if b>0 then local c=a.freereg;f:reserveregs(a,b)f:_nil(a,c,b)end end end;function b:enterlevel(a)a.L.nCcalls=a.L.nCcalls+1;if a.L.nCcalls>self.LUAI_MAXCCALLS then c:lexerror(a,"chunk has too many syntax levels",0)end end;function b:leavelevel(a)a.L.nCcalls=a.L.nCcalls-1 end;function b:enterblock(a,b,c)b.breaklist=f.NO_JUMP;b.isbreakable=c;b.nactvar=a.nactvar;b.upval=false;b.previous=a.bl;a.bl=b;h(a.freereg==a.nactvar)end;function b:leaveblock(a)local b=a.bl;a.bl=b.previous;self:removevars(a.ls,b.nactvar)if b.upval then f:codeABC(a,"OP_CLOSE",b.nactvar,0,0)end;h(not b.isbreakable or not b.upval)h(b.nactvar==a.nactvar)a.freereg=a.nactvar;f:patchtohere(a,b.breaklist)end;function b:pushclosure(a,b,c)local e=a.fs;local g=e.f;self:growvector(a.L,g.p,e.np,g.sizep,nil,d.MAXARG_Bx,"constant table overflow")g.p[e.np]=b.f;e.np=e.np+1;self:init_exp(c,"VRELOCABLE",f:codeABx(e,"OP_CLOSURE",0,e.np-1))for a=0,b.f.nups-1 do local c=b.upvalues[a].k=="VLOCAL"and"OP_MOVE"or"OP_GETUPVAL"f:codeABC(e,c,0,b.upvalues[a].info,0)end end;function b:open_func(a,b)local c=a.L;local d=self:newproto(a.L)b.f=d;b.prev=a.fs;b.ls=a;b.L=c;a.fs=b;b.pc=0;b.lasttarget=-1;b.jpc=f.NO_JUMP;b.freereg=0;b.nk=0;b.np=0;b.nlocvars=0;b.nactvar=0;b.bl=nil;d.source=a.source;d.maxstacksize=2;b.h={}end;function b:close_func(a)local b=a.L;local b=a.fs;local c=b.f;self:removevars(a,0)f:ret(b,0,0)c.sizecode=b.pc;c.sizelineinfo=b.pc;c.sizek=b.nk;c.sizep=b.np;c.sizelocvars=b.nlocvars;c.sizeupvalues=c.nups;h(b.bl==nil)a.fs=b.prev;if b then self:anchor_token(a)end end;function b:parser(a,b,d,e)local f={}f.t={}f.lookahead={}local g={}g.upvalues={}g.actvar={}a.nCcalls=0;f.buff=d;c:setinput(a,f,b,e)self:open_func(f,g)g.f.is_vararg=self.VARARG_ISVARARG;c:next(f)self:chunk(f)self:check(f,"TK_EOS")self:close_func(f)h(g.prev==nil)h(g.f.nups==0)h(f.fs==nil)return g.f end;function b:field(a,b)local d=a.fs;local e={}f:exp2anyreg(d,b)c:next(a)self:checkname(a,e)f:indexed(d,b,e)end;function b:yindex(a,b)c:next(a)self:expr(a,b)f:exp2val(a.fs,b)self:checknext(a,"]")end;function b:recfield(a,b)local c=a.fs;local d=a.fs.freereg;local e,g={},{}if a.t.token=="TK_NAME"then self:checklimit(c,b.nh,self.MAX_INT,"items in a constructor")self:checkname(a,e)else self:yindex(a,e)end;b.nh=b.nh+1;self:checknext(a,"=")local e=f:exp2RK(c,e)self:expr(a,g)f:codeABC(c,"OP_SETTABLE",b.t.info,e,f:exp2RK(c,g))c.freereg=d end;function b:closelistfield(a,b)if b.v.k=="VVOID"then return end;f:exp2nextreg(a,b.v)b.v.k="VVOID"if b.tostore==d.LFIELDS_PER_FLUSH then f:setlist(a,b.t.info,b.na,b.tostore)b.tostore=0 end end;function b:lastlistfield(a,b)if b.tostore==0 then return end;if self:hasmultret(b.v.k)then f:setmultret(a,b.v)f:setlist(a,b.t.info,b.na,self.LUA_MULTRET)b.na=b.na-1 else if b.v.k~="VVOID"then f:exp2nextreg(a,b.v)end;f:setlist(a,b.t.info,b.na,b.tostore)end end;function b:listfield(a,b)self:expr(a,b.v)self:checklimit(a.fs,b.na,self.MAX_INT,"items in a constructor")b.na=b.na+1;b.tostore=b.tostore+1 end;function b:constructor(a,b)local e=a.fs;local g=a.linenumber;local i=f:codeABC(e,"OP_NEWTABLE",0,0,0)local j={}j.v={}j.na,j.nh,j.tostore=0,0,0;j.t=b;self:init_exp(b,"VRELOCABLE",i)self:init_exp(j.v,"VVOID",0)f:exp2nextreg(a.fs,b)self:checknext(a,"{")repeat h(j.v.k=="VVOID"or j.tostore>0)if a.t.token=="}"then break end;self:closelistfield(e,j)local b=a.t.token;if b=="TK_NAME"then c:lookahead(a)if a.lookahead.token~="="then self:listfield(a,j)else self:recfield(a,j)end elseif b=="["then self:recfield(a,j)else self:listfield(a,j)end until not self:testnext(a,",")and not self:testnext(a,";")self:check_match(a,"}","{",g)self:lastlistfield(e,j)d:SETARG_B(e.f.code[i],self:int2fb(j.na))d:SETARG_C(e.f.code[i],self:int2fb(j.nh))end;function b:parlist(a)local b=a.fs;local d=b.f;local e=0;d.is_vararg=0;if a.t.token~=")"then repeat local b=a.t.token;if b=="TK_NAME"then self:new_localvar(a,self:str_checkname(a),e)e=e+1 elseif b=="TK_DOTS"then c:next(a)self:new_localvarliteral(a,"arg",e)e=e+1;d.is_vararg=self.VARARG_HASARG+self.VARARG_NEEDSARG;d.is_vararg=d.is_vararg+self.VARARG_ISVARARG else c:syntaxerror(a,"<name> or "..self:LUA_QL("...").." expected")end until d.is_vararg~=0 or not self:testnext(a,",")end;self:adjustlocalvars(a,e)d.numparams=b.nactvar-d.is_vararg%self.HASARG_MASK;f:reserveregs(b,b.nactvar)end;function b:body(a,b,c,d)local e={}e.upvalues={}e.actvar={}self:open_func(a,e)e.f.lineDefined=d;self:checknext(a,"(")if c then self:new_localvarliteral(a,"self",0)self:adjustlocalvars(a,1)end;self:parlist(a)self:checknext(a,")")self:chunk(a)e.f.lastlinedefined=a.linenumber;self:check_match(a,"TK_END","TK_FUNCTION",d)self:close_func(a)self:pushclosure(a,e,b)end;function b:explist1(a,b)local c=1;self:expr(a,b)while self:testnext(a,",")do f:exp2nextreg(a.fs,b)self:expr(a,b)c=c+1 end;return c end;function b:funcargs(a,b)local d=a.fs;local e={}local g;local i=a.linenumber;local j=a.t.token;if j=="("then if i~=a.lastline then c:syntaxerror(a,"ambiguous syntax (function call x new statement)")end;c:next(a)if a.t.token==")"then e.k="VVOID"else self:explist1(a,e)f:setmultret(d,e)end;self:check_match(a,")","(",i)elseif j=="{"then self:constructor(a,e)elseif j=="TK_STRING"then self:codestring(a,e,a.t.seminfo)c:next(a)else c:syntaxerror(a,"function arguments expected")return end;h(b.k=="VNONRELOC")local a=b.info;if self:hasmultret(e.k)then g=self.LUA_MULTRET else if e.k~="VVOID"then f:exp2nextreg(d,e)end;g=d.freereg-(a+1)end;self:init_exp(b,"VCALL",f:codeABC(d,"OP_CALL",a,g+1,2))f:fixline(d,i)d.freereg=a+1 end;function b:prefixexp(a,b)local d=a.t.token;if d=="("then local d=a.linenumber;c:next(a)self:expr(a,b)self:check_match(a,")","(",d)f:dischargevars(a.fs,b)elseif d=="TK_NAME"then self:singlevar(a,b)else c:syntaxerror(a,"unexpected symbol")end;return end;function b:primaryexp(a,b)local d=a.fs;self:prefixexp(a,b)while true do local e=a.t.token;if e=="."then self:field(a,b)elseif e=="["then local c={}f:exp2anyreg(d,b)self:yindex(a,c)f:indexed(d,b,c)elseif e==":"then local e={}c:next(a)self:checkname(a,e)f:_self(d,b,e)self:funcargs(a,b)elseif e=="("or e=="TK_STRING"or e=="{"then f:exp2nextreg(d,b)self:funcargs(a,b)else return end end end;function b:simpleexp(a,b)local d=a.t.token;if d=="TK_NUMBER"then self:init_exp(b,"VKNUM",0)b.nval=a.t.seminfo elseif d=="TK_STRING"then self:codestring(a,b,a.t.seminfo)elseif d=="TK_NIL"then self:init_exp(b,"VNIL",0)elseif d=="TK_TRUE"then self:init_exp(b,"VTRUE",0)elseif d=="TK_FALSE"then self:init_exp(b,"VFALSE",0)elseif d=="TK_DOTS"then local c=a.fs;self:check_condition(a,c.f.is_vararg~=0,"cannot use "..self:LUA_QL("...").." outside a vararg function")local a=c.f.is_vararg;if a>=self.VARARG_NEEDSARG then c.f.is_vararg=a-self.VARARG_NEEDSARG end;self:init_exp(b,"VVARARG",f:codeABC(c,"OP_VARARG",0,1,0))elseif d=="{"then self:constructor(a,b)return elseif d=="TK_FUNCTION"then c:next(a)self:body(a,b,false,a.linenumber)return else self:primaryexp(a,b)return end;c:next(a)end;function b:getunopr(a)if a=="TK_NOT"then return"OPR_NOT"elseif a=="-"then return"OPR_MINUS"elseif a=="#"then return"OPR_LEN"else return"OPR_NOUNOPR"end end;b.getbinopr_table={["+"]="OPR_ADD",["-"]="OPR_SUB",["*"]="OPR_MUL",["/"]="OPR_DIV",["%"]="OPR_MOD",["^"]="OPR_POW",["TK_CONCAT"]="OPR_CONCAT",["TK_NE"]="OPR_NE",["TK_EQ"]="OPR_EQ",["<"]="OPR_LT",["TK_LE"]="OPR_LE",[">"]="OPR_GT",["TK_GE"]="OPR_GE",["TK_AND"]="OPR_AND",["TK_OR"]="OPR_OR"}function b:getbinopr(a)local a=self.getbinopr_table[a]if a then return a else return"OPR_NOBINOPR"end end;b.priority={{6,6},{6,6},{7,7},{7,7},{7,7},{10,9},{5,4},{3,3},{3,3},{3,3},{3,3},{3,3},{3,3},{2,2},{1,1}}b.UNARY_PRIORITY=8;function b:subexpr(a,b,d)self:enterlevel(a)local e=self:getunopr(a.t.token)if e~="OPR_NOUNOPR"then c:next(a)self:subexpr(a,b,self.UNARY_PRIORITY)f:prefix(a.fs,e,b)else self:simpleexp(a,b)end;local e=self:getbinopr(a.t.token)while e~="OPR_NOBINOPR"and self.priority[f.BinOpr[e]+1][1]>d do local d={}c:next(a)f:infix(a.fs,e,b)local c=self:subexpr(a,d,self.priority[f.BinOpr[e]+1][2])f:posfix(a.fs,e,b,d)e=c end;self:leavelevel(a)return e end;function b:expr(a,b)self:subexpr(a,b,0)end;function b:block_follow(a)if a=="TK_ELSE"or a=="TK_ELSEIF"or a=="TK_END"or a=="TK_UNTIL"or a=="TK_EOS"then return true else return false end end;function b:block(a)local b=a.fs;local c={}self:enterblock(b,c,false)self:chunk(a)h(c.breaklist==f.NO_JUMP)self:leaveblock(b)end;function b:check_conflict(a,b,c)local a=a.fs;local d=a.freereg;local e=false;while b do if b.v.k=="VINDEXED"then if b.v.info==c.info then e=true;b.v.info=d end;if b.v.aux==c.info then e=true;b.v.aux=d end end;b=b.prev end;if e then f:codeABC(a,"OP_MOVE",a.freereg,c.info,0)f:reserveregs(a,1)end end;function b:assignment(a,b,c)local d={}local e=b.v.k;self:check_condition(a,e=="VLOCAL"or e=="VUPVAL"or e=="VGLOBAL"or e=="VINDEXED","syntax error")if self:testnext(a,",")then local d={}d.v={}d.prev=b;self:primaryexp(a,d.v)if d.v.k=="VLOCAL"then self:check_conflict(a,b,d.v)end;self:checklimit(a.fs,c,self.LUAI_MAXCCALLS-a.L.nCcalls,"variables in assignment")self:assignment(a,d,c+1)else self:checknext(a,"=")local e=self:explist1(a,d)if e~=c then self:adjust_assign(a,c,e,d)if e>c then a.fs.freereg=a.fs.freereg-(e-c)end else f:setoneret(a.fs,d)f:storevar(a.fs,b.v,d)return end end;self:init_exp(d,"VNONRELOC",a.fs.freereg-1)f:storevar(a.fs,b.v,d)end;function b:cond(a)local b={}self:expr(a,b)if b.k=="VNIL"then b.k="VFALSE"end;f:goiftrue(a.fs,b)return b.f end;function b:breakstat(a)local b=a.fs;local d=b.bl;local e=false;while d and not d.isbreakable do if d.upval then e=true end;d=d.previous end;if not d then c:syntaxerror(a,"no loop to break")end;if e then f:codeABC(b,"OP_CLOSE",d.nactvar,0,0)end;d.breaklist=f:concat(b,d.breaklist,f:jump(b))end;function b:whilestat(a,b)local d=a.fs;local e={}c:next(a)local c=f:getlabel(d)local g=self:cond(a)self:enterblock(d,e,true)self:checknext(a,"TK_DO")self:block(a)f:patchlist(d,f:jump(d),c)self:check_match(a,"TK_END","TK_WHILE",b)self:leaveblock(d)f:patchtohere(d,g)end;function b:repeatstat(a,b)local d=a.fs;local e=f:getlabel(d)local g,h={},{}self:enterblock(d,g,true)self:enterblock(d,h,false)c:next(a)self:chunk(a)self:check_match(a,"TK_UNTIL","TK_REPEAT",b)local b=self:cond(a)if not h.upval then self:leaveblock(d)f:patchlist(a.fs,b,e)else self:breakstat(a)f:patchtohere(a.fs,b)self:leaveblock(d)f:patchlist(a.fs,f:jump(d),e)end;self:leaveblock(d)end;function b:exp1(a)local b={}self:expr(a,b)local c=b.k;f:exp2nextreg(a.fs,b)return c end;function b:forbody(a,b,c,d,e)local g={}local h=a.fs;self:adjustlocalvars(a,3)self:checknext(a,"TK_DO")local i=e and f:codeAsBx(h,"OP_FORPREP",b,f.NO_JUMP)or f:jump(h)self:enterblock(h,g,false)self:adjustlocalvars(a,d)f:reserveregs(h,d)self:block(a)self:leaveblock(h)f:patchtohere(h,i)local a=e and f:codeAsBx(h,"OP_FORLOOP",b,f.NO_JUMP)or f:codeABC(h,"OP_TFORLOOP",b,0,d)f:fixline(h,c)f:patchlist(h,e and a or f:jump(h),i+1)end;function b:fornum(a,b,c)local d=a.fs;local e=d.freereg;self:new_localvarliteral(a,"(for index)",0)self:new_localvarliteral(a,"(for limit)",1)self:new_localvarliteral(a,"(for step)",2)self:new_localvar(a,b,3)self:checknext(a,'=')self:exp1(a)self:checknext(a,",")self:exp1(a)if self:testnext(a,",")then self:exp1(a)else f:codeABx(d,"OP_LOADK",d.freereg,f:numberK(d,1))f:reserveregs(d,1)end;self:forbody(a,e,c,1,true)end;function b:forlist(a,b)local c=a.fs;local d={}local e=0;local g=c.freereg;self:new_localvarliteral(a,"(for generator)",e)e=e+1;self:new_localvarliteral(a,"(for state)",e)e=e+1;self:new_localvarliteral(a,"(for control)",e)e=e+1;self:new_localvar(a,b,e)e=e+1;while self:testnext(a,",")do self:new_localvar(a,self:str_checkname(a),e)e=e+1 end;self:checknext(a,"TK_IN")local b=a.linenumber;self:adjust_assign(a,3,self:explist1(a,d),d)f:checkstack(c,3)self:forbody(a,g,b,e-3,false)end;function b:forstat(a,b)local d=a.fs;local e={}self:enterblock(d,e,true)c:next(a)local e=self:str_checkname(a)local f=a.t.token;if f=="="then self:fornum(a,e,b)elseif f==","or f=="TK_IN"then self:forlist(a,e)else c:syntaxerror(a,self:LUA_QL("=").." or "..self:LUA_QL("in").." expected")end;self:check_match(a,"TK_END","TK_FOR",b)self:leaveblock(d)end;function b:test_then_block(a)c:next(a)local b=self:cond(a)self:checknext(a,"TK_THEN")self:block(a)return b end;function b:ifstat(a,b)local d=a.fs;local e=f.NO_JUMP;local g=self:test_then_block(a)while a.t.token=="TK_ELSEIF"do e=f:concat(d,e,f:jump(d))f:patchtohere(d,g)g=self:test_then_block(a)end;if a.t.token=="TK_ELSE"then e=f:concat(d,e,f:jump(d))f:patchtohere(d,g)c:next(a)self:block(a)else e=f:concat(d,e,g)end;f:patchtohere(d,e)self:check_match(a,"TK_END","TK_IF",b)end;function b:localfunc(a)local b,c={},{}local d=a.fs;self:new_localvar(a,self:str_checkname(a),0)self:init_exp(b,"VLOCAL",d.freereg)f:reserveregs(d,1)self:adjustlocalvars(a,1)self:body(a,c,false,a.linenumber)f:storevar(d,b,c)self:getlocvar(d,d.nactvar-1).startpc=d.pc end;function b:localstat(a)local b=0;local c;local d={}repeat self:new_localvar(a,self:str_checkname(a),b)b=b+1 until not self:testnext(a,",")if self:testnext(a,"=")then c=self:explist1(a,d)else d.k="VVOID"c=0 end;self:adjust_assign(a,b,c,d)self:adjustlocalvars(a,b)end;function b:funcname(a,b)local c=false;self:singlevar(a,b)while a.t.token=="."do self:field(a,b)end;if a.t.token==":"then c=true;self:field(a,b)end;return c end;function b:funcstat(a,b)local d,e={},{}c:next(a)local c=self:funcname(a,d)self:body(a,e,c,b)f:storevar(a.fs,d,e)f:fixline(a.fs,b)end;function b:exprstat(a)local b=a.fs;local c={}c.v={}self:primaryexp(a,c.v)if c.v.k=="VCALL"then d:SETARG_C(f:getcode(b,c.v),1)else c.prev=nil;self:assignment(a,c,1)end end;function b:retstat(a)local b=a.fs;local e={}local g,i;c:next(a)if self:block_follow(a.t.token)or a.t.token==";"then g,i=0,0 else i=self:explist1(a,e)if self:hasmultret(e.k)then f:setmultret(b,e)if e.k=="VCALL"and i==1 then d:SET_OPCODE(f:getcode(b,e),"OP_TAILCALL")h(d:GETARG_A(f:getcode(b,e))==b.nactvar)end;g=b.nactvar;i=self.LUA_MULTRET else if i==1 then g=f:exp2anyreg(b,e)else f:exp2nextreg(b,e)g=b.nactvar;h(i==b.freereg-g)end end end;f:ret(b,g,i)end;function b:statement(a)local b=a.linenumber;local d=a.t.token;if d=="TK_IF"then self:ifstat(a,b)return false elseif d=="TK_WHILE"then self:whilestat(a,b)return false elseif d=="TK_DO"then c:next(a)self:block(a)self:check_match(a,"TK_END","TK_DO",b)return false elseif d=="TK_FOR"then self:forstat(a,b)return false elseif d=="TK_REPEAT"then self:repeatstat(a,b)return false elseif d=="TK_FUNCTION"then self:funcstat(a,b)return false elseif d=="TK_LOCAL"then c:next(a)if self:testnext(a,"TK_FUNCTION")then self:localfunc(a)else self:localstat(a)end;return false elseif d=="TK_RETURN"then self:retstat(a)return true elseif d=="TK_BREAK"then c:next(a)self:breakstat(a)return true else self:exprstat(a)return false end end;function b:chunk(a)local b=false;self:enterlevel(a)while not b and not self:block_follow(a.t.token)do b=self:statement(a)self:testnext(a,";")h(a.fs.f.maxstacksize>=a.fs.freereg and a.fs.freereg>=a.fs.nactvar)a.fs.freereg=a.fs.nactvar end;self:leavelevel(a)end;c:init()local c={}return function(d,f)f=f or'compiled-lua'local a=a:init(a:make_getF(d),nil)if not a then return end;local a=b:parser(c,a,nil,"@"..f)local b,d=e:make_setS()e:dump(c,a,b,d)return d.data end end)(),FiOne=(function()if not bit then local a=nil;pcall(function()a=require('bit')end)bit=a end;local a=bit or bit32 or(function()local a={_TYPE='module',_NAME='bit.numberlua',_VERSION='0.3.1.20120131'}local b=math.floor;local c=2^32;local d=c-1;local function e(a)local b={}local c=setmetatable({},b)function b:__index(b)local a=a(b)c[b]=a;return a end;return c end;local function f(a,b)local function c(c,d)local e,f=0,1;while c~=0 and d~=0 do local g,h=c%b,d%b;e=e+a[g][h]*f;c=(c-g)/b;d=(d-h)/b;f=f*b end;e=e+(c+d)*f;return e end;return c end;local function g(a)local b=f(a,2^1)local b=e(function(a)return e(function(c)return b(a,c)end)end)return f(b,2^(a.n or 1))end;function a.tobit(a)return a%2^32 end;a.bxor=g{[0]={[0]=0,[1]=1},[1]={[0]=1,[1]=0},n=4}local e=a.bxor;function a.bnot(a)return d-a end;local f=a.bnot;function a.band(a,b)return(a+b-e(a,b))/2 end;local g=a.band;function a.bor(a,b)return d-g(d-a,d-b)end;local h=a.bor;local i,j;function a.rshift(a,c)if c<0 then return i(a,-c)end;return b(a%2^32/2^c)end;j=a.rshift;function a.lshift(a,b)if b<0 then return j(a,-b)end;return a*2^b%2^32 end;i=a.lshift;function a.tohex(a,b)b=b or 8;local c;if b<=0 then if b==0 then return''end;c=true;b=-b end;a=g(a,16^b-1)return('%0'..b..(c and'X'or'x')):format(a)end;local b=a.tohex;function a.extract(a,b,c)c=c or 1;return g(j(a,b),2^c-1)end;local k=a.extract;function a.replace(a,b,c,d)d=d or 1;local d=2^d-1;b=g(b,d)local d=f(i(d,c))return g(a,d)+i(b,c)end;local l=a.replace;function a.bswap(a)local b=g(a,255)a=j(a,8)local c=g(a,255)a=j(a,8)local d=g(a,255)a=j(a,8)local a=g(a,255)return i(i(i(b,8)+c,8)+d,8)+a end;local m=a.bswap;function a.rrotate(a,b)b=b%32;local c=g(a,2^b-1)return j(a,b)+i(c,32-b)end;local n=a.rrotate;function a.lrotate(a,b)return n(a,-b)end;local o=a.lrotate;a.rol=a.lrotate;a.ror=a.rrotate;function a.arshift(a,b)local c=j(a,b)if a>=2147483648 then c=c+i(2^b-1,32-b)end;return c end;local p=a.arshift;function a.btest(a,b)return g(a,b)~=0 end;a.bit32={}local function q(a)return(-1-a)%c end;a.bit32.bnot=q;local function q(a,b,d,...)local f;if b then a=a%c;b=b%c;f=e(a,b)if d then f=q(f,d,...)end;return f elseif a then return a%c else return 0 end end;a.bit32.bxor=q;local function q(a,b,f,...)local g;if b then a=a%c;b=b%c;g=(a+b-e(a,b))/2;if f then g=q(g,f,...)end;return g elseif a then return a%c else return d end end;a.bit32.band=q;local function r(a,b,e,...)local f;if b then a=a%c;b=b%c;f=d-g(d-a,d-b)if e then f=r(f,e,...)end;return f elseif a then return a%c else return 0 end end;a.bit32.bor=r;function a.bit32.btest(...)return q(...)~=0 end;function a.bit32.lrotate(a,b)return o(a%c,b)end;function a.bit32.rrotate(a,b)return n(a%c,b)end;function a.bit32.lshift(a,b)if b>31 or b<-31 then return 0 end;return i(a%c,b)end;function a.bit32.rshift(a,b)if b>31 or b<-31 then return 0 end;return j(a%c,b)end;function a.bit32.arshift(a,b)a=a%c;if b>=0 then if b>31 then return a>=2147483648 and d or 0 else local c=j(a,b)if a>=2147483648 then c=c+i(2^b-1,32-b)end;return c end else return i(a,-b)end end;function a.bit32.extract(a,b,...)local d=...or 1;if b<0 or b>31 or d<0 or b+d>32 then error'out of range'end;a=a%c;return k(a,b,...)end;function a.bit32.replace(a,b,d,...)local e=...or 1;if d<0 or d>31 or e<0 or d+e>32 then error'out of range'end;a=a%c;b=b%c;return l(a,b,d,...)end;a.bit={}function a.bit.tobit(a)a=a%c;if a>=2147483648 then a=a-c end;return a end;local d=a.bit.tobit;function a.bit.tohex(a,...)return b(a%c,...)end;function a.bit.bnot(a)return d(f(a%c))end;local function b(a,e,f,...)if f then return b(b(a,e),f,...)elseif e then return d(h(a%c,e%c))else return d(a)end end;a.bit.bor=b;local function b(a,e,f,...)if f then return b(b(a,e),f,...)elseif e then return d(g(a%c,e%c))else return d(a)end end;a.bit.band=b;local function b(a,f,g,...)if g then return b(b(a,f),g,...)elseif f then return d(e(a%c,f%c))else return d(a)end end;a.bit.bxor=b;function a.bit.lshift(a,b)return d(i(a%c,b%32))end;function a.bit.rshift(a,b)return d(j(a%c,b%32))end;function a.bit.arshift(a,b)return d(p(a%c,b%32))end;function a.bit.rol(a,b)return d(o(a%c,b%32))end;function a.bit.ror(a,b)return d(n(a%c,b%32))end;function a.bit.bswap(a)return d(m(a%c))end;return a end)()local b=table.unpack or unpack;local c;local d;local e;local g=50;local h={[22]=18,[31]=8,[33]=28,[0]=3,[1]=13,[2]=23,[26]=33,[12]=1,[13]=6,[14]=10,[15]=16,[16]=20,[17]=26,[18]=30,[19]=36,[3]=0,[4]=2,[5]=4,[6]=7,[7]=9,[8]=12,[9]=14,[10]=17,[20]=19,[21]=22,[23]=24,[24]=27,[25]=29,[27]=32,[32]=34,[34]=37,[11]=5,[28]=11,[29]=15,[30]=21,[35]=25,[36]=31,[37]=35}local i={[0]='ABC','ABx','ABC','ABC','ABC','ABx','ABC','ABx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','AsBx','ABC','ABC','ABC','ABx','ABC'}local j={[0]={b='OpArgR',c='OpArgN'},{b='OpArgK',c='OpArgN'},{b='OpArgU',c='OpArgU'},{b='OpArgR',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgK',c='OpArgN'},{b='OpArgR',c='OpArgK'},{b='OpArgK',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgK',c='OpArgK'},{b='OpArgU',c='OpArgU'},{b='OpArgR',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgR'},{b='OpArgR',c='OpArgN'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgR',c='OpArgU'},{b='OpArgR',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgU',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgN',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgN',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgU',c='OpArgN'}}local function k(a,b,c,d)local e=0;for c=b,c,d do e=e+string.byte(a,c,c)*256^(c-b)end;return e end;local function l(b,c,d,e)local f=(-1)^a.rshift(e,7)local e=a.rshift(d,7)+a.lshift(a.band(e,127),1)local a=b+a.lshift(c,8)+a.lshift(a.band(d,127),16)local b=1;if e==0 then if a==0 then return f*0 else b=0;e=1 end elseif e==127 then if a==0 then return f*1/0 else return f*0/0 end end;return f*2^(e-127)*(1+b/2^23)end;local function m(b,c,d,e,f,g,h,i)local j=(-1)^a.rshift(i,7)local i=a.lshift(a.band(i,127),4)+a.rshift(h,4)local a=a.band(h,15)*2^48;local h=1;a=a+g*2^40+f*2^32+e*2^24+d*2^16+c*2^8+b;if i==0 then if a==0 then return j*0 else h=0;i=1 end elseif i==2047 then if a==0 then return j*1/0 else return j*0/0 end end;return j*2^(i-1023)*(h+a/2^52)end;local function n(a,b,c)return k(a,b,c-1,1)end;local function o(a,b,c)return k(a,c-1,b,-1)end;local function k(a,b)return l(string.byte(a,b,b+3))end;local function p(a,b)local a,b,c,d=string.byte(a,b,b+3)return l(d,c,b,a)end;local function l(a,b)return m(string.byte(a,b,b+7))end;local function q(a,b)local a,b,c,d,e,f,g,h=string.byte(a,b,b+7)return m(h,g,f,e,d,c,b,a)end;local k={[4]={little=k,big=p},[8]={little=l,big=q}}local function l(a)local b=a.index;local c=string.byte(a.source,b,b)a.index=b+1;return c end;local function m(a,b)local b=a.index+b;local c=string.sub(a.source,a.index,b-1)a.index=b;return c end;local function p(a)local b=a:s_szt()local c;if b~=0 then c=string.sub(m(a,b),1,-2)end;return c end;local function q(a,b)return function(c)local a=c.index+a;local b=b(c.source,c.index,a)c.index=a;return b end end;local function r(a,b)return function(c)local b=b(c.source,c.index)c.index=c.index+a;return b end end;local function s(b)local c=b:s_int()local d={}for c=1,c do local b=b:s_ins()local e=a.band(b,63)local f=i[e]local g=j[e]local e={value=b,op=h[e],A=a.band(a.rshift(b,6),255)}if f=='ABC'then e.B=a.band(a.rshift(b,23),511)e.C=a.band(a.rshift(b,14),511)e.is_KB=g.b=='OpArgK'and e.B>255;e.is_KC=g.c=='OpArgK'and e.C>255 elseif f=='ABx'then e.Bx=a.band(a.rshift(b,14),262143)e.is_K=g.b=='OpArgK'elseif f=='AsBx'then e.sBx=a.band(a.rshift(b,14),262143)-131071 end;d[c]=e end;return d end;local function a(a)local b=a:s_int()local c={}for b=1,b do local d=l(a)local e;if d==1 then e=l(a)~=0 elseif d==3 then e=a:s_num()elseif d==4 then e=p(a)end;c[b]=e end;return c end;local function i(a,b)local c=a:s_int()local d={}for c=1,c do d[c]=e(a,b)end;return d end;local function j(a)local b=a:s_int()local c={}for b=1,b do c[b]=a:s_int()end;return c end;local function t(a)local b=a:s_int()local c={}for b=1,b do c[b]={varname=p(a),startpc=a:s_int(),endpc=a:s_int()}end;return c end;local function u(a)local b=a:s_int()local c={}for b=1,b do c[b]=p(a)end;return c end;function e(b,c)local d={}local c=p(b)or c;d.source=c;b:s_int()b:s_int()d.numupvals=l(b)d.numparams=l(b)l(b)l(b)d.code=s(b)d.const=a(b)d.subs=i(b,c)d.lines=j(b)t(b)u(b)for a,a in ipairs(d.code)do if a.is_K then a.const=d.const[a.Bx+1]else if a.is_KB then a.const_B=d.const[a.B-255]end;if a.is_KC then a.const_C=d.const[a.C-255]end end end;return d end;function c(a)local b;local c;local d;local f;local g;local h;local i;local a={index=1,source=a}assert(m(a,4)=='\27Lua','invalid Lua signature')assert(l(a)==81,'invalid Lua version')assert(l(a)==0,'invalid Lua format')c=l(a)~=0;d=l(a)f=l(a)g=l(a)h=l(a)i=l(a)~=0;b=c and n or o;a.s_int=q(d,b)a.s_szt=q(f,b)a.s_ins=q(g,b)if i then a.s_num=q(h,b)elseif k[h]then a.s_num=r(h,k[h][c and'little'or'big'])else error('unsupported float size')end;return e(a,'@virtual')end;local function a(a,b)for c,d in pairs(a)do if d.index>=b then d.value=d.store[d.index]d.store=d;d.index='value'a[c]=nil end end end;local function e(a,b,c)local d=a[b]if not d then d={index=b,store=c}a[b]=d end;return d end;local function i(...)return select('#',...),{...}end;local function j(a,b)local c=a.source;local a=a.lines[a.pc-1]local d,e,f=string.match(b,'^(.-):(%d+):%s+(.+)')local g='%s:%i: [%s:%i] %s'a=a or'0'd=d or'?'e=e or'0'f=f or b;error(string.format(g,c,a,d,e,f),0)end;local function k(c)local f=c.code;local j=c.subs;local k=c.env;local l=c.upvals;local m=c.varargs;local n=-1;local o={}local p=c.stack;local q=c.pc;while true do local r=f[q]local s=r.op;q=q+1;if s<18 then if s<8 then if s<3 then if s<1 then for a=r.A,r.B do p[a]=nil end elseif s>1 then local a=l[r.B]p[r.A]=a.store[a.index]else local a,b;if r.is_KB then a=r.const_B else a=p[r.B]end;if r.is_KC then b=r.const_C else b=p[r.C]end;p[r.A]=a+b end elseif s>3 then if s<6 then if s>4 then local a=r.A;local b=r.B;local c;if r.is_KC then c=r.const_C else c=p[r.C]end;p[a+1]=p[b]p[a]=p[b][c]else p[r.A]=k[r.const]end elseif s>6 then local a;if r.is_KC then a=r.const_C else a=p[r.C]end;p[r.A]=p[r.B][a]else local a,b;if r.is_KB then a=r.const_B else a=p[r.B]end;if r.is_KC then b=r.const_C else b=p[r.C]end;p[r.A]=a-b end else p[r.A]=p[r.B]end elseif s>8 then if s<13 then if s<10 then k[r.const]=p[r.A]elseif s>10 then if s<12 then local a=r.A;local c=r.B;local d=r.C;local e;local f,g;if c==0 then e=n-a else e=c-1 end;f,g=i(p[a](b(p,a+1,a+e)))if d==0 then n=a+f-1 else f=d-1 end;for b=1,f do p[a+b-1]=g[b]end else local a=l[r.B]a.store[a.index]=p[r.A]end else local a,b;if r.is_KB then a=r.const_B else a=p[r.B]end;if r.is_KC then b=r.const_C else b=p[r.C]end;p[r.A]=a*b end elseif s>13 then if s<16 then if s>14 then local c=r.A;local d=r.B;local e;if d==0 then e=n-c else e=d-1 end;a(o,0)return i(p[c](b(p,c+1,c+e)))else local a,b;if r.is_KB then a=r.const_B else a=p[r.B]end;if r.is_KC then b=r.const_C else b=p[r.C]end;p[r.A][a]=b end elseif s>16 then p[r.A]={}else local a,b;if r.is_KB then a=r.const_B else a=p[r.B]end;if r.is_KC then b=r.const_C else b=p[r.C]end;p[r.A]=a/b end else p[r.A]=r.const end else local a=r.A;local b=p[a+2]local c=p[a]+b;local a=p[a+1]local d;if b==math.abs(b)then d=c<=a else d=c>=a end;if d then p[r.A]=c;p[r.A+3]=c;q=q+r.sBx end end elseif s>18 then if s<28 then if s<23 then if s<20 then p[r.A]=#p[r.B]elseif s>20 then if s<22 then local b=r.A;local c=r.B;local d={}local e;if c==0 then e=n-b+1 else e=c-1 end;for a=1,e do d[a]=p[b+a-1]end;a(o,0)return e,d else local a=p[r.B]for b=r.B+1,r.C do a=a..p[b]end;p[r.A]=a end else local a,b;if r.is_KB then a=r.const_B else a=p[r.B]end;if r.is_KC then b=r.const_C else b=p[r.C]end;p[r.A]=a%b end elseif s>23 then if s<26 then if s>24 then a(o,r.A)else local a,b;if r.is_KB then a=r.const_B else a=p[r.B]end;if r.is_KC then b=r.const_C else b=p[r.C]end;if a==b==(r.A~=0)then q=q+f[q].sBx end;q=q+1 end elseif s>26 then local a,b;if r.is_KB then a=r.const_B else a=p[r.B]end;if r.is_KC then b=r.const_C else b=p[r.C]end;if a<b==(r.A~=0)then q=q+f[q].sBx end;q=q+1 else local a,b;if r.is_KB then a=r.const_B else a=p[r.B]end;if r.is_KC then b=r.const_C else b=p[r.C]end;p[r.A]=a^b end else p[r.A]=r.B~=0;if r.C~=0 then q=q+1 end end elseif s>28 then if s<33 then if s<30 then local a,b;if r.is_KB then a=r.const_B else a=p[r.B]end;if r.is_KC then b=r.const_C else b=p[r.C]end;if a<=b==(r.A~=0)then q=q+f[q].sBx end;q=q+1 elseif s>30 then if s<32 then local a=j[r.Bx+1]local b=a.numupvals;local c;if b~=0 then c={}for a=1,b do local b=f[q+a-1]if b.op==h[0]then c[a-1]=e(o,b.B,p)elseif b.op==h[4]then c[a-1]=l[b.B]end end;q=q+b end;p[r.A]=d(a,k,c)else local a=r.A;local b=r.B;if not p[b]==(r.C~=0)then q=q+1 else p[a]=p[b]end end else p[r.A]=-p[r.B]end elseif s>33 then if s<36 then if s>34 then local a=r.A;local b=r.B;if b==0 then b=m.size;n=a+b-1 end;for b=1,b do p[a+b-1]=m.list[b]end else local a=r.A;local b,c,d;b=assert(tonumber(p[a]),'`for` initial value must be a number')c=assert(tonumber(p[a+1]),'`for` limit must be a number')d=assert(tonumber(p[a+2]),'`for` step must be a number')p[a]=b-d;p[a+1]=c;p[a+2]=d;q=q+r.sBx end elseif s>36 then local a=r.A;local b=r.C;local c=r.B;local d=p[a]local e;if c==0 then c=n-a end;if b==0 then b=r[q].value;q=q+1 end;e=(b-1)*g;for b=1,c do d[b+e]=p[a+b]end else p[r.A]=not p[r.B]end else if not p[r.A]==(r.C~=0)then q=q+1 end end else local a=r.A;local b=p[a]local c=p[a+1]local d=p[a+2]local e=a+3;local f;p[e+2]=d;p[e+1]=c;p[e]=b;f={b(c,d)}for a=1,r.C do p[e+a-1]=f[a]end;if p[e]~=nil then p[a+2]=p[e]else q=q+1 end end else q=q+r.sBx end;c.pc=q end end;function d(a,c,d)local e=a.code;local f=a.subs;local g=a.lines;local h=a.source;local a=a.numparams;local function l(...)local l={}local m={}local n=0;local i,o=i(...)local p;local q,r,s;for a=1,a do l[a-1]=o[a]end;if a<i then n=i-a;for b=1,n do m[b]=o[a+b]end end;p={varargs={list=m,size=n},code=e,subs=f,lines=g,source=h,env=c,upvals=d,stack=l,pc=1}q,r,s=pcall(k,p,...)if q then return b(s,1,r)else j(p,r)end;return end;return l end;return function(a,b)return d(c(a),b or f(0))end end)(),FiOneCode=[==[(function()if not bit then local bit_=nil pcall(function()bit_=require('bit') end)bit=bit_ end local bit=bit or bit32 or(function()local a={_TYPE='module',_NAME='bit.numberlua',_VERSION='0.3.1.20120131'}local b=math.floor;local c=2^32;local d=c-1;local function e(f)local g={}local h=setmetatable({},g)function g:__index(i)local j=f(i)h[i]=j;return j end;return h end;local function k(h,l)local function m(n,o)local p,q=0,1;while n~=0 and o~=0 do local r,s=n%l,o%l;p=p+h[r][s]*q;n=(n-r)/l;o=(o-s)/l;q=q*l end;p=p+(n+o)*q;return p end;return m end;local function t(h)local u=k(h,2^1)local v=e(function(n)return e(function(o)return u(n,o)end)end)return k(v,2^(h.n or 1))end;function a.tobit(w)return w%2^32 end;a.bxor=t{[0]={[0]=0,[1]=1},[1]={[0]=1,[1]=0},n=4}local x=a.bxor;function a.bnot(n)return d-n end;local y=a.bnot;function a.band(n,o)return(n+o-x(n,o))/2 end;local z=a.band;function a.bor(n,o)return d-z(d-n,d-o)end;local A=a.bor;local B,C;function a.rshift(n,D)if D<0 then return B(n,-D)end;return b(n%2^32/2^D)end;C=a.rshift;function a.lshift(n,D)if D<0 then return C(n,-D)end;return n*2^D%2^32 end;B=a.lshift;function a.tohex(w,E)E=E or 8;local F;if E<=0 then if E==0 then return''end;F=true;E=-E end;w=z(w,16^E-1)return('%0'..E..(F and'X'or'x')):format(w)end;local G=a.tohex;function a.extract(E,H,I)I=I or 1;return z(C(E,H),2^I-1)end;local J=a.extract;function a.replace(E,j,H,I)I=I or 1;local K=2^I-1;j=z(j,K)local L=y(B(K,H))return z(E,L)+B(j,H)end;local M=a.replace;function a.bswap(w)local n=z(w,0xff)w=C(w,8)local o=z(w,0xff)w=C(w,8)local N=z(w,0xff)w=C(w,8)local O=z(w,0xff)return B(B(B(n,8)+o,8)+N,8)+O end;local P=a.bswap;function a.rrotate(w,D)D=D%32;local Q=z(w,2^D-1)return C(w,D)+B(Q,32-D)end;local R=a.rrotate;function a.lrotate(w,D)return R(w,-D)end;local S=a.lrotate;a.rol=a.lrotate;a.ror=a.rrotate;function a.arshift(w,D)local T=C(w,D)if w>=0x80000000 then T=T+B(2^D-1,32-D)end;return T end;local U=a.arshift;function a.btest(w,V)return z(w,V)~=0 end;a.bit32={}local function W(w)return(-1-w)%c end;a.bit32.bnot=W;local function X(n,o,N,...)local T;if o then n=n%c;o=o%c;T=x(n,o)if N then T=X(T,N,...)end;return T elseif n then return n%c else return 0 end end;a.bit32.bxor=X;local function Y(n,o,N,...)local T;if o then n=n%c;o=o%c;T=(n+o-x(n,o))/2;if N then T=Y(T,N,...)end;return T elseif n then return n%c else return d end end;a.bit32.band=Y;local function Z(n,o,N,...)local T;if o then n=n%c;o=o%c;T=d-z(d-n,d-o)if N then T=Z(T,N,...)end;return T elseif n then return n%c else return 0 end end;a.bit32.bor=Z;function a.bit32.btest(...)return Y(...)~=0 end;function a.bit32.lrotate(w,D)return S(w%c,D)end;function a.bit32.rrotate(w,D)return R(w%c,D)end;function a.bit32.lshift(w,D)if D>31 or D<-31 then return 0 end;return B(w%c,D)end;function a.bit32.rshift(w,D)if D>31 or D<-31 then return 0 end;return C(w%c,D)end;function a.bit32.arshift(w,D)w=w%c;if D>=0 then if D>31 then return w>=0x80000000 and d or 0 else local T=C(w,D)if w>=0x80000000 then T=T+B(2^D-1,32-D)end;return T end else return B(w,-D)end end;function a.bit32.extract(w,H,...)local I=...or 1;if H<0 or H>31 or I<0 or H+I>32 then error'out of range'end;w=w%c;return J(w,H,...)end;function a.bit32.replace(w,j,H,...)local I=...or 1;if H<0 or H>31 or I<0 or H+I>32 then error'out of range'end;w=w%c;j=j%c;return M(w,j,H,...)end;a.bit={}function a.bit.tobit(w)w=w%c;if w>=0x80000000 then w=w-c end;return w end;local _=a.bit.tobit;function a.bit.tohex(w,...)return G(w%c,...)end;function a.bit.bnot(w)return _(y(w%c))end;local function a0(n,o,N,...)if N then return a0(a0(n,o),N,...)elseif o then return _(A(n%c,o%c))else return _(n)end end;a.bit.bor=a0;local function a1(n,o,N,...)if N then return a1(a1(n,o),N,...)elseif o then return _(z(n%c,o%c))else return _(n)end end;a.bit.band=a1;local function a2(n,o,N,...)if N then return a2(a2(n,o),N,...)elseif o then return _(x(n%c,o%c))else return _(n)end end;a.bit.bxor=a2;function a.bit.lshift(w,E)return _(B(w%c,E%32))end;function a.bit.rshift(w,E)return _(C(w%c,E%32))end;function a.bit.arshift(w,E)return _(U(w%c,E%32))end;function a.bit.rol(w,E)return _(S(w%c,E%32))end;function a.bit.ror(w,E)return _(R(w%c,E%32))end;function a.bit.bswap(w)return _(P(w%c))end;return a end)()local unpack=table.unpack or unpack;local a3;local a4;local a5;local a6=50;local a7={[22]=18,[31]=8,[33]=28,[0]=3,[1]=13,[2]=23,[26]=33,[12]=1,[13]=6,[14]=10,[15]=16,[16]=20,[17]=26,[18]=30,[19]=36,[3]=0,[4]=2,[5]=4,[6]=7,[7]=9,[8]=12,[9]=14,[10]=17,[20]=19,[21]=22,[23]=24,[24]=27,[25]=29,[27]=32,[32]=34,[34]=37,[11]=5,[28]=11,[29]=15,[30]=21,[35]=25,[36]=31,[37]=35}local a8={[0]='ABC','ABx','ABC','ABC','ABC','ABx','ABC','ABx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','AsBx','ABC','ABC','ABC','ABx','ABC'}local a9={[0]={b='OpArgR',c='OpArgN'},{b='OpArgK',c='OpArgN'},{b='OpArgU',c='OpArgU'},{b='OpArgR',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgK',c='OpArgN'},{b='OpArgR',c='OpArgK'},{b='OpArgK',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgK',c='OpArgK'},{b='OpArgU',c='OpArgU'},{b='OpArgR',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgR'},{b='OpArgR',c='OpArgN'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgR',c='OpArgU'},{b='OpArgR',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgU',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgN',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgN',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgU',c='OpArgN'}}local function aa(ab,s,e,d)local ac=0;for i=s,e,d do ac=ac+string.byte(ab,i,i)*256^(i-s)end;return ac end;local function ad(ae,af,ag,ah)local ai=(-1)^bit.rshift(ah,7)local aj=bit.rshift(ag,7)+bit.lshift(bit.band(ah,0x7F),1)local ak=ae+bit.lshift(af,8)+bit.lshift(bit.band(ag,0x7F),16)local al=1;if aj==0 then if ak==0 then return ai*0 else al=0;aj=1 end elseif aj==0x7F then if ak==0 then return ai*1/0 else return ai*0/0 end end;return ai*2^(aj-127)*(1+al/2^23)end;local function am(ae,af,ag,ah,an,ao,ap,aq)local ai=(-1)^bit.rshift(aq,7)local aj=bit.lshift(bit.band(aq,0x7F),4)+bit.rshift(ap,4)local ak=bit.band(ap,0x0F)*2^48;local al=1;ak=ak+ao*2^40+an*2^32+ah*2^24+ag*2^16+af*2^8+ae;if aj==0 then if ak==0 then return ai*0 else al=0;aj=1 end elseif aj==0x7FF then if ak==0 then return ai*1/0 else return ai*0/0 end end;return ai*2^(aj-1023)*(al+ak/2^52)end;local function ar(ab,s,e)return aa(ab,s,e-1,1)end;local function as(ab,s,e)return aa(ab,e-1,s,-1)end;local function at(ab,s)return ad(string.byte(ab,s,s+3))end;local function au(ab,s)local ae,af,ag,ah=string.byte(ab,s,s+3)return ad(ah,ag,af,ae)end;local function av(ab,s)return am(string.byte(ab,s,s+7))end;local function aw(ab,s)local ae,af,ag,ah,an,ao,ap,aq=string.byte(ab,s,s+7)return am(aq,ap,ao,an,ah,ag,af,ae)end;local ax={[4]={little=at,big=au},[8]={little=av,big=aw}}local function ay(S)local az=S.index;local aA=string.byte(S.source,az,az)S.index=az+1;return aA end;local function aB(S,aC)local aD=S.index+aC;local aE=string.sub(S.source,S.index,aD-1)S.index=aD;return aE end;local function aF(S)local aC=S:s_szt()local aE;if aC~=0 then aE=string.sub(aB(S,aC),1,-2)end;return aE end;local function aG(aC,aH)return function(S)local aD=S.index+aC;local aI=aH(S.source,S.index,aD)S.index=aD;return aI end end;local function aJ(aC,aH)return function(S)local aK=aH(S.source,S.index)S.index=S.index+aC;return aK end end;local function aL(S)local aM=S:s_int()local aN={}for i=1,aM do local aO=S:s_ins()local aP=bit.band(aO,0x3F)local aQ=a8[aP]local aR=a9[aP]local aS={value=aO,op=a7[aP],A=bit.band(bit.rshift(aO,6),0xFF)}if aQ=='ABC'then aS.B=bit.band(bit.rshift(aO,23),0x1FF)aS.C=bit.band(bit.rshift(aO,14),0x1FF)aS.is_KB=aR.b=='OpArgK'and aS.B>0xFF;aS.is_KC=aR.c=='OpArgK'and aS.C>0xFF elseif aQ=='ABx'then aS.Bx=bit.band(bit.rshift(aO,14),0x3FFFF)aS.is_K=aR.b=='OpArgK'elseif aQ=='AsBx'then aS.sBx=bit.band(bit.rshift(aO,14),0x3FFFF)-131071 end;aN[i]=aS end;return aN end;local function aT(S)local aM=S:s_int()local aU={}for i=1,aM do local aV=ay(S)local k;if aV==1 then k=ay(S)~=0 elseif aV==3 then k=S:s_num()elseif aV==4 then k=aF(S)end;aU[i]=k end;return aU end;local function aW(S,ab)local aM=S:s_int()local aX={}for i=1,aM do aX[i]=a5(S,ab)end;return aX end;local function aY(S)local aM=S:s_int()local aZ={}for i=1,aM do aZ[i]=S:s_int()end;return aZ end;local function a_(S)local aM=S:s_int()local b0={}for i=1,aM do b0[i]={varname=aF(S),startpc=S:s_int(),endpc=S:s_int()}end;return b0 end;local function b1(S)local aM=S:s_int()local b2={}for i=1,aM do b2[i]=aF(S)end;return b2 end;function a5(S,b3)local b4={}local ab=aF(S)or b3;b4.source=ab;S:s_int()S:s_int()b4.numupvals=ay(S)b4.numparams=ay(S)ay(S)ay(S)b4.code=aL(S)b4.const=aT(S)b4.subs=aW(S,ab)b4.lines=aY(S)a_(S)b1(S)for _,v in ipairs(b4.code)do if v.is_K then v.const=b4.const[v.Bx+1]else if v.is_KB then v.const_B=b4.const[v.B-0xFF]end;if v.is_KC then v.const_C=b4.const[v.C-0xFF]end end end;return b4 end;function a3(ab)local b5;local b6;local b7;local b8;local b9;local ba;local bb;local bc={index=1,source=ab}assert(aB(bc,4)=='\27Lua','invalid Lua signature')assert(ay(bc)==0x51,'invalid Lua version')assert(ay(bc)==0,'invalid Lua format')b6=ay(bc)~=0;b7=ay(bc)b8=ay(bc)b9=ay(bc)ba=ay(bc)bb=ay(bc)~=0;b5=b6 and ar or as;bc.s_int=aG(b7,b5)bc.s_szt=aG(b8,b5)bc.s_ins=aG(b9,b5)if bb then bc.s_num=aG(ba,b5)elseif ax[ba]then bc.s_num=aJ(ba,ax[ba][b6 and'little'or'big'])else error('unsupported float size')end;return a5(bc,'@virtual')end;local function bd(be,bf)for i,bg in pairs(be)do if bg.index>=bf then bg.value=bg.store[bg.index]bg.store=bg;bg.index='value'be[i]=nil end end end;local function bh(be,bf,bi)local bj=be[bf]if not bj then bj={index=bf,store=bi}be[bf]=bj end;return bj end;local function bk(...)return select('#',...),{...}end;local function bl(bm,bn)local ab=bm.source;local bo=bm.lines[bm.pc-1]local b3,bp,bq=string.match(bn,'^(.-):(%d+):%s+(.+)')local br='%s:%i: [%s:%i] %s'bo=bo or'0'b3=b3 or'?'bp=bp or'0'bq=bq or bn;error(string.format(br,ab,bo,b3,bp,bq),0)end;local function bs(bm)local aN=bm.code;local bt=bm.subs;local bu=bm.env;local bv=bm.upvals;local bw=bm.varargs;local bx=-1;local by={}local bi=bm.stack;local bz=bm.pc;while true do local bA=aN[bz]local aP=bA.op;bz=bz+1;if aP<18 then if aP<8 then if aP<3 then if aP<1 then for i=bA.A,bA.B do bi[i]=nil end elseif aP>1 then local bg=bv[bA.B]bi[bA.A]=bg.store[bg.index]else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;bi[bA.A]=bB+bC end elseif aP>3 then if aP<6 then if aP>4 then local A=bA.A;local B=bA.B;local bf;if bA.is_KC then bf=bA.const_C else bf=bi[bA.C]end;bi[A+1]=bi[B]bi[A]=bi[B][bf]else bi[bA.A]=bu[bA.const]end elseif aP>6 then local bf;if bA.is_KC then bf=bA.const_C else bf=bi[bA.C]end;bi[bA.A]=bi[bA.B][bf]else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;bi[bA.A]=bB-bC end else bi[bA.A]=bi[bA.B]end elseif aP>8 then if aP<13 then if aP<10 then bu[bA.const]=bi[bA.A]elseif aP>10 then if aP<12 then local A=bA.A;local B=bA.B;local C=bA.C;local bD;local bE,bF;if B==0 then bD=bx-A else bD=B-1 end;bE,bF=bk(bi[A](unpack(bi,A+1,A+bD)))if C==0 then bx=A+bE-1 else bE=C-1 end;for i=1,bE do bi[A+i-1]=bF[i]end else local bg=bv[bA.B]bg.store[bg.index]=bi[bA.A]end else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;bi[bA.A]=bB*bC end elseif aP>13 then if aP<16 then if aP>14 then local A=bA.A;local B=bA.B;local bD;if B==0 then bD=bx-A else bD=B-1 end;bd(by,0)return bk(bi[A](unpack(bi,A+1,A+bD)))else local bf,bG;if bA.is_KB then bf=bA.const_B else bf=bi[bA.B]end;if bA.is_KC then bG=bA.const_C else bG=bi[bA.C]end;bi[bA.A][bf]=bG end elseif aP>16 then bi[bA.A]={}else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;bi[bA.A]=bB/bC end else bi[bA.A]=bA.const end else local A=bA.A;local bH=bi[A+2]local bf=bi[A]+bH;local bI=bi[A+1]local bJ;if bH==math.abs(bH)then bJ=bf<=bI else bJ=bf>=bI end;if bJ then bi[bA.A]=bf;bi[bA.A+3]=bf;bz=bz+bA.sBx end end elseif aP>18 then if aP<28 then if aP<23 then if aP<20 then bi[bA.A]=#bi[bA.B]elseif aP>20 then if aP<22 then local A=bA.A;local B=bA.B;local bK={}local aM;if B==0 then aM=bx-A+1 else aM=B-1 end;for i=1,aM do bK[i]=bi[A+i-1]end;bd(by,0)return aM,bK else local aE=bi[bA.B]for i=bA.B+1,bA.C do aE=aE..bi[i]end;bi[bA.A]=aE end else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;bi[bA.A]=bB%bC end elseif aP>23 then if aP<26 then if aP>24 then bd(by,bA.A)else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;if bB==bC==(bA.A~=0)then bz=bz+aN[bz].sBx end;bz=bz+1 end elseif aP>26 then local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;if bB<bC==(bA.A~=0)then bz=bz+aN[bz].sBx end;bz=bz+1 else local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;bi[bA.A]=bB^bC end else bi[bA.A]=bA.B~=0;if bA.C~=0 then bz=bz+1 end end elseif aP>28 then if aP<33 then if aP<30 then local bB,bC;if bA.is_KB then bB=bA.const_B else bB=bi[bA.B]end;if bA.is_KC then bC=bA.const_C else bC=bi[bA.C]end;if bB<=bC==(bA.A~=0)then bz=bz+aN[bz].sBx end;bz=bz+1 elseif aP>30 then if aP<32 then local aX=bt[bA.Bx+1]local bL=aX.numupvals;local bM;if bL~=0 then bM={}for i=1,bL do local bN=aN[bz+i-1]if bN.op==a7[0]then bM[i-1]=bh(by,bN.B,bi)elseif bN.op==a7[4]then bM[i-1]=bv[bN.B]end end;bz=bz+bL end;bi[bA.A]=a4(aX,bu,bM)else local A=bA.A;local B=bA.B;if not bi[B]==(bA.C~=0)then bz=bz+1 else bi[A]=bi[B]end end else bi[bA.A]=-bi[bA.B]end elseif aP>33 then if aP<36 then if aP>34 then local A=bA.A;local aM=bA.B;if aM==0 then aM=bw.size;bx=A+aM-1 end;for i=1,aM do bi[A+i-1]=bw.list[i]end else local A=bA.A;local bO,bI,bH;bO=assert(tonumber(bi[A]),'`for` initial value must be a number')bI=assert(tonumber(bi[A+1]),'`for` limit must be a number')bH=assert(tonumber(bi[A+2]),'`for` step must be a number')bi[A]=bO-bH;bi[A+1]=bI;bi[A+2]=bH;bz=bz+bA.sBx end elseif aP>36 then local A=bA.A;local C=bA.C;local aM=bA.B;local bP=bi[A]local bQ;if aM==0 then aM=bx-A end;if C==0 then C=bA[bz].value;bz=bz+1 end;bQ=(C-1)*a6;for i=1,aM do bP[i+bQ]=bi[A+i]end else bi[bA.A]=not bi[bA.B]end else if not bi[bA.A]==(bA.C~=0)then bz=bz+1 end end else local A=bA.A;local aH=bi[A]local bR=bi[A+1]local bf=bi[A+2]local bS=A+3;local bK;bi[bS+2]=bf;bi[bS+1]=bR;bi[bS]=aH;bK={aH(bR,bf)}for i=1,bA.C do bi[bS+i-1]=bK[i]end;if bi[bS]~=nil then bi[A+2]=bi[bS]else bz=bz+1 end end else bz=bz+bA.sBx end;bm.pc=bz end end;function a4(bR,bu,b2)local bT=bR.code;local bU=bR.subs;local bV=bR.lines;local bW=bR.source;local bX=bR.numparams;local function bY(...)local bi={}local bZ={}local b_=0;local c0,c1=bk(...)local bm;local c2,bn,bK;for i=1,bX do bi[i-1]=c1[i]end;if bX<c0 then b_=c0-bX;for i=1,b_ do bZ[i]=c1[bX+i]end end;bm={varargs={list=bZ,size=b_},code=bT,subs=bU,lines=bV,source=bW,env=bu,upvals=b2,stack=bi,pc=1}c2,bn,bK=pcall(bs,bm,...)if c2 then return unpack(bK,1,bn)else bl(bm,bn)end;return end;return bY end;return function(c3,bu)return a4(a3(c3),bu or fev(0))end end)()]==],AES=nil,AESCode=[==[(function()local function a(b)local c={}for d=0,255 do c[d]={}end;c[0][0]=b[1]*255;local e=1;for f=0,7 do for d=0,e-1 do for g=0,e-1 do local h=c[d][g]-b[1]*e;c[d][g+e]=h+b[2]*e;c[d+e][g]=h+b[3]*e;c[d+e][g+e]=h+b[4]*e end end;e=e*2 end;return c end;local i=a{0,1,1,0}local function j(self,k)local l,d,g=self.S,self.i,self.j;local m={}local n=string.char;for o=1,k do d=(d+1)%256;g=(g+l[d])%256;l[d],l[g]=l[g],l[d]m[o]=n(l[(l[d]+l[g])%256])end;self.i,self.j=d,g;return table.concat(m)end;local function p(self,q)local r=j(self,#q)local s={}local t=string.byte;local n=string.char;for d=1,#q do s[d]=n(i[t(q,d)][t(r,d)])end;return table.concat(s)end;local function u(self,v)local l=self.S;local g,w=0,#v;local t=string.byte;for d=0,255 do g=(g+l[d]+t(v,d%w+1))%256;l[d],l[g]=l[g],l[d]end end;function new(v)local l={}local s={S=l,i=0,j=0,generate=j,cipher=p,schedule=u}for d=0,255 do l[d]=d end;if v then s:schedule(v)end;return s end;return new end)()]==],Base64={Encode=function(a)local b=d;return(a:gsub('.',function(a)local a,b='',a:byte()for c=8,1,-1 do a=a..(b%2^c-b%2^(c-1)>0 and'1'or'0')end;return a end)..'0000'):gsub('%d%d%d?%d?%d?%d?',function(a)if#a<6 then return''end;local c=0;for b=1,6 do c=c+(a:sub(b,b)=='1'and 2^(6-b)or 0)end;return b:sub(c+1,c+1)end)..({'','==','='})[#a%3+1]end,Decode=function(a)local b=d;a=string.gsub(a,'[^'..b..'=]','')return a:gsub('.',function(a)if a=='='then return''end;local a,b='',b:find(a)-1;for c=6,1,-1 do a=a..(b%2^c-b%2^(c-1)>0 and'1'or'0')end;return a end):gsub('%d%d%d?%d?%d?%d?%d?%d?',function(a)if#a~=8 then return''end;local b=0;for c=1,8 do b=b+(a:sub(c,c)=='1'and 2^(8-c)or 0)end;return string.char(b)end)end},Base64Code={Encode=[==[function(a)local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';return(a:gsub('.',function(c)local d,b='',c:byte()for e=8,1,-1 do d=d..(b%2^e-b%2^(e-1)>0 and'1'or'0')end;return d end)..'0000'):gsub('%d%d%d?%d?%d?%d?',function(c)if#c<6 then return''end;local f=0;for e=1,6 do f=f+(c:sub(e,e)=='1'and 2^(6-e)or 0)end;return b:sub(f+1,f+1)end)..({'','==','='})[#a%3+1]end]==],Decode=[==[function(a)local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';a=string.gsub(a,'[^'..b..'=]','')return a:gsub('.',function(c)if c=='='then return''end;local d,e='',b:find(c)-1;for f=6,1,-1 do d=d..(e%2^f-e%2^(f-1)>0 and'1'or'0')end;return d end):gsub('%d%d%d?%d?%d?%d?%d?%d?',function(c)if#c~=8 then return''end;local g=0;for f=1,8 do g=g+(c:sub(f,f)=='1'and 2^(8-f)or 0)end;return string.char(g)end)end]==]}}function loaddata(a)return d[a]end;local g=loaddata("Yueliang")local h=loaddata("FiOne")local i=loadstring;do loadstring=function(a,b,c)local a=g(a,b or nil)local a=h(a,c or f(2))return a end;d.AES=loadstring("return "..loaddata("AESCode"))()end;local d={comment="// CRYPTED",variablecomment="lol you have to stop trying to deobfuscate",cryptvarcomment=true,variablename="CRYPTED"}local f=loaddata("AES")local h=loaddata("Base64")local function i(a,b)local b=f(b)local a=b:cipher(a)local a=h.Encode(a)return a end;local function j(a,b)local b=f(b)local a=h.Decode(a)local a=b:cipher(a)return a end;local function f(a)local b=""for a=1,a do local a=math.random(1,#e)b=b..e:sub(a,a)end;return b end;local e={['0']='0000',['1']='0001',['2']='0010',['3']='0011',['4']='0100',['5']='0101',['6']='0110',['7']='0111',['8']='1000',['9']='1001',['A']='1010',['B']='1011',['C']='1100',['D']='1101',['E']='1110',['F']='1111'}local function j(a)return('%X'):format(a):upper():gsub(".",e)end;local function e(a)return j((a):byte(1,-1)):gsub("0","i"):gsub("1","I")end;c.crypt=function(a,b)b=b or{}for a,c in pairs(d)do if b[a]==nil then b[a]=c end end;b.variablename=b.variablename:gsub('[%p%c%s]','_')b.variablename=b.variablename:sub(1,1):gsub('[%d]','v'..b.variablename:sub(1,1))..b.variablename:sub(2)local c=b.variablename;local d=b.cryptvarcomment and"\\"..table.concat({b.variablecomment:byte(1,-1)},"\\")or b.variablecomment;local b=b.comment;print("Obfuscating | Code conversion...")local a,g=pcall(function()return g(a,"gg_y")end)if a==false then print("Lua Error")return error(g)end;print("Obfuscating | Encrypting...")local a="return (function()"local j=("local %s%s = \"%s\";"):format(c,e("z"),d)local k=("local %s%s"):format(c,e("a"))local l=("local %s%s"):format(c,e("b"))local m=("local %s%s"):format(c,e("c"))local n=("local %s%s"):format(c,e("d"))local o=("local %s%s"):format(c,e("e"))local p=("local %s%s"):format(c,e("f"))local q=("local %s%s"):format(c,e("g"))local r=f(math.random(10,20))local g=i(h.Encode(g),r)local i=h.Encode(r)print("Obfuscating | Code Building...")local r=o.."="..("'%s'"):format(h.Encode(f(math.random(10,20))))local d=p.."="..("'%s'"):format(d)local q=q.."="..("'%s'"):format(h.Encode(f(math.random(10,20))))local i=n.."="..("'%s'"):format("\\"..table.concat({i:byte(1,-1)},"\\"))local d={r,d,q,i}local q=("%s%s"):format(c,e("i"))local r=("local %s"):format(q).."="..loaddata("Base64Code").Decode;local s=("%s%s"):format(c,e("j"))local t=("local %s"):format(s).."="..loaddata("AESCode")local u=("%s%s"):format(c,e("k"))local v=("local %s"):format(u).."="..loaddata("FiOneCode")local o=[[function ]]..("%s%s"):format(c,e("h"))..[[(a,b)local c=]]..q..[[(a,b);local d=]]..o:sub(7)..[[;return c,d end]]local p=("%s%s"):format(c,e("h"))..("(%s,%d)"):format(p:sub(7),math.random(314,31415))local p=("%s%s"):format(c,e("m"))local q=("local %s"):format(p).."=".."function(a,b)".."local c="..s.."("..q.."(a))".."local d=c[\"\\99\\105\\112\\104\\101\\114\"](c,"..q.."(b))".."return "..q.."(d)".."end"local s=("%s%s"):format(c,e("n"))local w=nil;if g:len()>255 then local a={}for b=1,#g,255 do a[#a+1]={g:sub(b,b+255-1):byte(1,-1)}end;w={}for a,a in pairs(a)do for a,a in pairs(a)do w[#w+1]=a end end else w={g:byte(1,-1)}end;local g="\\"..table.concat(w,"\\")local g=("local %s"):format(s).."="..("\"%s\""):format(g)local w="local fev=getfenv or function()return _ENV end"local c=("local %s%s"):format(c,e("o")).."="..("'%s%s%s'"):format(h.Encode(f(math.random(10,20))),h.Encode(f(math.random(10,20))),h.Encode(f(math.random(10,20))))local e=("return %s(%s(%s,%s),getfenv(0))()end)()"):format(u,p,(n):sub(7),s)print("Obfuscated!")return b.."\n\n"..a..j..j..j..k.."="..("%d"):format(math.random(111,31415)/100)..";"..l.."="..("%d"):format(math.random(111,31415)/100)..";"..m.."="..("%d"):format(math.pi)..";"..r..";"..l.."="..("%d"):format(math.random(111,31415)/100)..";"..t..";"..w..";"..v..";"..d[math.random(1,#d)]..";"..g..";"..d[math.random(1,#d)]..";"..d[math.random(1,#d)]..";"..q..";"..d[math.random(1,#d)]..";"..i..";"..d[math.random(1,#d)]..";"..c..";"..o..";"..e end;if a==true then local a,e,f=pcall(function()return io.open(b.source,"rb")end)if a==false or e==nil then print("File (source file) Reading Error: "..(a==false and e or f or"Unknown"))return end;print(("Selected source file to \"%s\"."):format(b.source))local a,f,g=pcall(function()return io.open(b.output or"output.lua","w")end)if a==false or f==nil then e:close()print("File (output file) Writing Error: "..(a==false and f or g or"Unknown"))return end;print(("Selected output file to \"%s\"."):format(b.output or"output.lua"))local a={comment=b.comment or d.comment,variablecomment=b.varcomm or d.variablecomment,cryptvarcomment=b.cryptvarcomm or false,variablename=b.varname or d.variablename}local d=os.clock()print("Starting obfuscation.")local a=c.crypt(e:read("*a"),a)print(("Finished obfuscation in %d seconds."):format(os.clock()-d))e:close()f:write(a)f:close()a=nil;print(("Obfuscated code are written to \"%s\"."):format(b.output or"output.lua"))print("All done.")return end;return setmetatable(c,{__call=function(a,b,c)return a.crypt(b,c)end})
 
